<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.9: http://docutils.sourceforge.net/" />
<title>Timers</title>
<meta name="author" content="Cory Sharp, Martin Turon" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2005-10-31 22:16:36 $
:version: $Revision: 1.1.2.1 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/
body {
  font-family: Times;
  font-size: 16px;
}

.first {
  margin-top: 0 ! important }

.last {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dd {
  margin-bottom: 0.5em }

/* Uncomment (& remove this text!) to get bold-faced definition list terms
dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1 {
  font-family: Arial, sans-serif;
  font-size: 20px;
}

h1.title {
 text-align: center;
 font-size: 32px;
}

h2 {
 font-size: 16px;
 font-family: Arial, sans-serif;
}

h2.subtitle {
  text-align: center }

h3 {
 font-size: 12px;
 font-family: Arial, sans-serif;
}

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em;
}

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap;
  }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="timers">
<h1 class="title">Timers</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">102</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Core Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Documentary</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.x</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Cory Sharp, Martin Turon</td></tr>
<tr class="field"><th class="docinfo-name">Draft-Created:</th><td class="field-body">22-Sep-2004</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Version:</th><td class="field-body">1.16</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Modified:</th><td class="field-body">2005-10-11</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Discuss:</th><td class="field-body">TinyOS Developer List &lt;tinyos-devel at mail.millennium.berkeley.edu&gt;</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This memo documents a part of TinyOS for the TinyOS Community, and
requests discussion and suggestions for improvements.  Distribution
of this memo is unlimited.  This memo is in full compliance with
TEP 1.</p>
</div>
<div class="section" id="abstract">
<h1><a name="abstract">Abstract</a></h1>
<p>This TEP proposes a Timer design that supports common timing
requirements both in precision and width across common hardware
configurations.  This TEP focuses on aligning the Timer abstraction
with the three-layer Hardware Abstraction Architecture (HAA).</p>
</div>
<div class="section" id="overview">
<h1><a name="overview">Overview</a></h1>
<p>This TEP proposes a timer system which supports a set of basic
event-driven timing operations for common timing fidelities.</p>
<p>Fidelity is the combination of precision and width.  Examples of
precision are millisecond, a cycle of a 32kHz clock, and
microseconds.  Examples of widths are 8-bit, 16-bit, 32-bit, and
64-bit.</p>
<p>The most basic behavior on time is to measure it.  This TEP defines
&quot;counters&quot; that provide a free running count of time.  &quot;Free
running&quot; means that time continues counting even if interrupts are
disabled or code enters an atomic section.  This is the standard and
expected behavior, and it means that timer code must be constructed
specifically with an understanding of any implications from it.</p>
<p>The next most basic behavior on time is to wait.  This TEP defines
&quot;alarms&quot; that can fire an event when a <em>counter</em> reaches a specified
value.  HAL level alarms can only set single events, and this TEP
proposes functionality to allow virtualization of a single HAL alarm.</p>
<p>The components proposed by this TEP are constructed to handle
overflow of the counters, which is inevitable.</p>
<p>This TEP proposes all timer interfaces be parameterized by
precision.  All precisions are in &quot;binary&quot; units with respect to one
second.  Precision is expressed an empty type</p>
<ul class="simple">
<li>TMilli</li>
<li>T32khz</li>
<li>TMicro</li>
</ul>
<p>These HAL interfaces are proposed:</p>
<ul class="simple">
<li>Counter</li>
<li>Alarm</li>
<li>BusyWait</li>
</ul>
<p>The Counter and Alarm interfaces are fundamental components to be
implemented by each hardware platform.  A Counter is a free running
clock, and an Alarm can schedule a single asynchronous event for
some specified time.  These interfaces are parameterized by
precision and size.  The most common sizes are 16-bit and 32-bit.
Some platforms will likely use 8-bit for internal implementation,
and it is expected that some future platforms will use 64-bit.</p>
<p>These of platform dependent HAL components MUST exist:</p>
<ul class="simple">
<li>Alarm32khzC</li>
<li>AlarmMilliC</li>
<li>BusyWait32khzC</li>
<li>BusyWaitMicroC</li>
<li>Counter32khzC</li>
<li>CounterMilliC</li>
</ul>
<p>A number of platform independent generic components are provided by
the TinyOS timer system to help derive the full HAL requirements with
minimal source code:</p>
<ul class="simple">
<li>AlarmToTimerC</li>
<li>BusyWaitCounterC</li>
<li>CounterToLocalTimeC</li>
<li>TransformAlarmC</li>
<li>TransformCounterC</li>
<li>VirtualizeTimerC</li>
</ul>
<p>It is expected that a platform only needs to directly implement in
code concise Counter and Alarm components expressed in the
platform-native precision and width.  It SHOULD be possible to
implement the remaining timer system by using only configurations and
platform independent generic timer components.</p>
<p>These HIL interfaces are proposed:</p>
<ul class="simple">
<li>LocalTime</li>
<li>Timer</li>
</ul>
<p>LocalTime and Timer are HIL versions of Counter and Alarm.
LocalTime is a simplified version Counter in that it does not expose
overflow.  Timer can schedule single or periodic synchronous events
at some specified time.  The LocalTime and Timer interfaces are used
primarily by user applications and use a fixed width of 32-bits.</p>
<p>This HAL component MUST also exist:</p>
<ul class="simple">
<li>HalTimerMilliC</li>
</ul>
</div>
<div class="section" id="precision-and-width">
<h1><a name="precision-and-width">Precision and Width</a></h1>
<p>Two fundamental properties of timers are <em>precision</em> and <em>width</em>.</p>
<p>Examples of precision are millisecond, a cycle of a 32kHz clock, and
microseconds.  All precisions are in &quot;binary&quot; units with respect to
one second.  That is, one second contains 1024 binary milliseconds,
32768 32kHz ticks, or 1048576 microseconds.  This TEP emphasizes
millisecond and 32kHz tick precisions while reasonably accommodating
other precisions.</p>
<p>Examples of widths are 8-bit, 16-bit, 32-bit, and 64-bit.  The width
for timer interfaces and components SHOULD be 32-bits.  That is, for
lack of a good reason, timer interfaces should expose a 32-bit
interface.  In a number of circumstances there are good reasons not
to expose a 32-bit interface.  This TEP emphasizes 32-bit widths
while reasonably accommodating other widths.</p>
<p>This TEP parameterizes all interfaces by precision and some
interfaces by width.  This intentionally makes similar timer
interfaces with different precision or width mutually incompatible.
It also allows user code to clearly express and understand the
precision and width for a given timer interface.</p>
<p>Precision is expressed as an empty type -- TMilli, T32khz, and
TMicro -- written in the standard Timer.h header like this:</p>
<pre class="literal-block">
typedef struct { } TMilli;
typedef struct { } T32khz;
typedef struct { } TMicro;
</pre>
<p>Note that the precision names are expressed as either frequency or
period, whichever is convenient.</p>
</div>
<div class="section" id="hpl-layer">
<h1><a name="hpl-layer">HPL Layer</a></h1>
<p>At the lowest level, the HPLTimerC wraps all the hardware registers
that control the hardware subsystem.  The specifics of these interfaces 
are dependant on the chip that contains the timer subsystem.  But certain
design paterns can be followed:</p>
<blockquote>
HplTimer&lt;width&gt;   - get/set current time, overflow event, control, init
HplCompare&lt;width&gt; - get/set compare time, fired event,    control
HplCapture&lt;width&gt; - get/set capture time, captured event, control, config</blockquote>
<p>Note that on a platform that has multiple timers of variable width, it 
is helpful to abstract the width out of the interface at the HPL level 
if possible.  This simplifies higher level interfaces by allowing them to
wire to any timer in the system trivially.</p>
<p>One sample set of HPL level interfaces follows:</p>
<pre class="literal-block">
interface HplTimer&lt;timer_size&gt;
{
  /// Timer value register: Direct access
  async command timer_size get();
  async command void       set( timer_size t );

  /// Interrupt signals
  async event void overflow();        //&lt;! Signalled on overflow interrupt

  /// Interrupt flag utilites: Bit level set/clr
  async command void reset(); //&lt;! Clear the overflow interrupt flag
  async command void start(); //&lt;! Enable the overflow interrupt
  async command void stop();  //&lt;! Turn off overflow interrupts
  async command bool test();  //&lt;! Did overflow interrupt occur?
  async command bool isOn();  //&lt;! Is overflow interrupt on?

  /// Clock initialization interface
  async command void    off();                     //&lt;! Turn off the clock 
  async command void    setScale( uint8_t scale);  //&lt;! Turn on the clock
  async command uint8_t getScale();                //&lt;! Get prescaler setting
}

interface HplCompare&lt;size_type&gt;
{
  /// Compare value register: Direct access
  async command size_type get();
  async command void      set(size_type t);

  /// Interrupt signals
  async event void fired();           //&lt;! Signalled on compare interrupt

  /// Interrupt flag utilites: Bit level set/clr
  async command void reset();         //&lt;! Clear the compare interrupt flag
  async command void start();         //&lt;! Enable the compare interrupt
  async command void stop();          //&lt;! Turn off comparee interrupts
  async command bool test();          //&lt;! Did compare interrupt occur?
  async command bool isOn();          //&lt;! Is compare interrupt on?
}

interface HplCapture&lt;size_type&gt;
{
  /// Capture value register: Direct access
  async command size_type get();
  async command void      set(size_type t);

  /// Interrupt signals
  async event void captured(size_type t);  //&lt;! Signalled on capture int

  /// Interrupt flag utilites: Bit level set/clr  
  async command void reset();          //&lt;! Clear the capture interrupt flag
  async command void start();          //&lt;! Enable the capture interrupt
  async command void stop();           //&lt;! Turn off capture interrupts
  async command bool test();           //&lt;! Did capture interrupt occur?
  async command bool isOn();           //&lt;! Is capture interrupt on?

  async command void setEdge(bool up); //&lt;! True = detect rising edge
}
</pre>
</div>
<div class="section" id="hal-interfaces">
<h1><a name="hal-interfaces">HAL Interfaces</a></h1>
<p>This TEP proposes these HAL timer interfaces:</p>
<pre class="literal-block">
interface Counter&lt; precision_tag, size_type &gt;
interface Alarm&lt; precision_tag, size_type &gt;
interface BusyWait&lt; precision_tag, size_type &gt;
</pre>
<div class="section" id="counter">
<h2><a name="counter">Counter</a></h2>
<p>A Counter component will increase the width of a low-level hardware timer 
by wrapping the overflow event and incrementing its higher order bits.
These higher order bits are considered extra state over the HPL register
layer, and therefore qualify all Counters as HAL components.
The Counter interface returns the current time and provides commands
and an event for managing overflow conditions.  These overflow
commands and events are necessary for properly deriving larger width
Counters from smaller widths.</p>
<pre class="literal-block">
interface Counter&lt;precision_tag,size_type&gt;
{
  async command size_type get();
  async command bool isOverflowPending();
  async command void clearOverflow();
  async event void overflow();
}
</pre>
<dl class="docutils">
<dt>get() </dt>
<dd>return the current time.</dd>
<dt>isOverflowPending() </dt>
<dd>return TRUE if an overflow interrupt will occur after the outermost
atomic block is exits.  FALSE otherwise.</dd>
<dt>clearOverflow() </dt>
<dd>cancel the pending overflow interrupt.</dd>
<dt>overflow() </dt>
<dd>signals that an overflow in the current time.  That is, the current
time has wrapped around from its maximum value to zero.</dd>
</dl>
</div>
<div class="section" id="alarm">
<h2><a name="alarm">Alarm</a></h2>
<p>Alarm components are extensions of Counters that signal an event
when their Compare register detects the alarm time has been hit.
All commands and events of the Alarm interface are asynchronous (or
in &quot;interrupt context&quot;).  The Alarm interface provides a set of
&quot;basic&quot; commands for common usage and provides a set of &quot;extended&quot;
commands for advanced use.</p>
<pre class="literal-block">
interface Alarm&lt;precision_tag,size_type&gt;
{
  // basic interface
  async command void start( size_type dt );
  async command void stop();
  async event void fired();

  // extended interface
  async command bool isRunning();
  async command void startAt( size_type t0, size_type dt );
  async command size_type getNow();
  async command size_type getAlarm();
}
</pre>
<dl class="docutils">
<dt>start(dt) </dt>
<dd>cancel any previously running alarm and set to fire in dt time units
from the time of invocation.  The alarm will only fire once then
stop.</dd>
<dt>stop() </dt>
<dd>cancel any previously running alarm.</dd>
<dt>fired() </dt>
<dd>signals that the alarm has occurred.</dd>
<dt>isRunning() </dt>
<dd>return TRUE if the alarm has been started and has not been cancelled
or has not yet fired.  FALSE is returned otherwise.</dd>
<dt>startAt(t0,dt) </dt>
<dd>cancel any previously running alarm and set to fire at time t1 =
t0+dt.  This form allows a delay to be anchored to some time t0
taken before the invocation of start.  This is also the form used
internally in the timer subsystem to allow the use of the full width
of an alarm while being able to detect if the alarm time for a short
alarm prematurely elapsed.</dd>
<dt>getNow() </dt>
<dd>return the current time in the precision and width of the alarm.</dd>
<dt>getAlarm() </dt>
<dd>return the time the currently running alarm will fire or the time
that the previously running alarm was set to fire.</dd>
</dl>
</div>
<div class="section" id="busywait">
<h2><a name="busywait">BusyWait</a></h2>
<p>The BusyWait interface replaces the TOSH_uwait macro from TinyOS
1.x.</p>
<pre class="literal-block">
interface BusyWait&lt;precision_tag,size_type&gt;
{
  async command void wait( size_type dt );
}
</pre>
<dl class="docutils">
<dt>wait(dt)</dt>
<dd>block for no less than the specified amount of time.</dd>
</dl>
</div>
</div>
<div class="section" id="hil-interfaces">
<h1><a name="hil-interfaces">HIL Interfaces</a></h1>
<p>This TEP proposes these HIL timer interfaces:</p>
<pre class="literal-block">
interface LocalTime&lt; precision_tag &gt;
interface Timer&lt; precision_tag &gt;
</pre>
<p>The LocalTime and Timer interfaces are used primarily by user
applications and use a fixed width of 32-bits.  The Alarm, BusyWait,
and Counter interfaces are used by the TinyOS timer system and
advanced user components.</p>
<div class="section" id="localtime">
<h2><a name="localtime">LocalTime</a></h2>
<p>The LocalTime interface exposes a 32-bit counter without overflow
utilities.  This is primarily for application code that does not
care about overflow conditions.</p>
<pre class="literal-block">
interface LocalTime&lt;precision_tag&gt;
{
  async command uint32_t get();
}
</pre>
<dl class="docutils">
<dt>get() </dt>
<dd>return the current time.</dd>
</dl>
</div>
<div class="section" id="timer">
<h2><a name="timer">Timer</a></h2>
<p>All commands and events of the Timer interface are synchronous (or
in &quot;task context&quot;).  The Timer interface provides a set of &quot;basic&quot;
commands for common usage and provides a set of &quot;extended&quot; commands
for advanced use.  The Timer interface allows for periodic events.</p>
<pre class="literal-block">
interface Timer&lt;precision_tag&gt;
{
  // basic interface
  command void startPeriodic( uint32_t dt );
  command void startOneShot( uint32_t dt );
  command void stop();
  event void fired();

  // extended interface
  command bool isRunning();
  command bool isOneShot();
  command void startPeriodicAt( uint32_t t0, uint32_t dt );
  command void startOneShotAt( uint32_t t0, uint32_t dt );
  command uint32_t getNow();
  command uint32_t gett0();
  command uint32_t getdt();
}
</pre>
<dl class="docutils">
<dt>startPeriodic(dt) </dt>
<dd>cancel any previously running timer and set to fire in dt time units
from the time of invocation.  The timer will fire periodically every
dt time units until stopped.</dd>
<dt>startOneShot(dt) </dt>
<dd>cancel any previously running timer and set to fire in dt time units
from the time of invocation.  The timer will only fire once then
stop.</dd>
<dt>stop() </dt>
<dd>cancel any previously running timer.</dd>
<dt>fired()</dt>
<dd>signals that the timer has occurred.</dd>
<dt>isRunning() </dt>
<dd>return TRUE if the timer has been started and has not been cancelled
and has not fired for the case of one-shot timers.  One a periodic
timer is started, isRunning will return TRUE until it is cancelled.</dd>
<dt>isOneShot() </dt>
<dd>return TRUE if the timer is a one-shot timer.  Return FALSE
otherwise if the timer is a periodic timer.</dd>
<dt>startPeriodicAt(t0,dt) </dt>
<dd>cancel any previously running timer and set to fire at time t1 =
t0+dt.  The timer will fire periodically every dt time units until
stopped.</dd>
<dt>startOneShotAt(t0,dt) </dt>
<dd>cancel any previously running timer and set to fire at time t1 =
t0+dt.  The timer will fire once then stop.</dd>
<dt>getNow() </dt>
<dd>return the current time in the precision and width of the timer.</dd>
<dt>gett0() </dt>
<dd>return the time anchor for the previously started timer or the time
of the previous event for periodic timers.</dd>
<dt>getdt() </dt>
<dd>return the delay or period for the previously started timer.</dd>
</dl>
</div>
</div>
<div class="section" id="hil-platform-independent-components">
<h1><a name="hil-platform-independent-components">HIL: Platform independent components</a></h1>
<p>A number of platform independent generic components are provided by
the TinyOS timer system:</p>
<ul class="simple">
<li>AlarmToTimerC</li>
<li>BusyWaitCounterC</li>
<li>CounterToLocalTimeC</li>
<li>TransformAlarmC</li>
<li>TransformCounterC</li>
<li>VirtualizeTimerC</li>
</ul>
<p>The platform independent components are used to help derive the
platform dependent components discussed in the next section.</p>
<div class="section" id="alarmtotimerc">
<h2><a name="alarmtotimerc">AlarmToTimerC</a></h2>
<p>AlarmToTimerC converts a 32-bit Alarm to a Timer.</p>
<pre class="literal-block">
generic component AlarmToTimerC( typedef precision_tag )
{
  provides interface Timer&lt;precision_tag&gt;;
  uses interface Alarm&lt;precision_tag,uint32_t&gt;;
}
</pre>
</div>
<div class="section" id="busywaitcounterc">
<h2><a name="busywaitcounterc">BusyWaitCounterC</a></h2>
<p>BusyWaitCounterC uses a Counter to block until a specified amount of
time elapses.</p>
<pre class="literal-block">
generic component BusyWaitC( typedef precision_tag,
  typedef size_type &#64;integer() )
{
  provides interface BusyWait&lt;precision_tag,size_type&gt;;
  uses interface Counter&lt;precision_tag,size_type&gt;;
}
</pre>
</div>
<div class="section" id="countertolocaltimec">
<h2><a name="countertolocaltimec">CounterToLocalTimeC</a></h2>
<p>CounterToLocalTimeC converts from a 32-bit Counter to LocalTime.</p>
<pre class="literal-block">
generic component CounterToLocalTimeC( precision_tag )
{
  provides interface LocalTime&lt;precision_tag&gt;;
  uses interface Counter&lt;precision_tag,uint32_t&gt;;
}
</pre>
</div>
<div class="section" id="transformalarmc">
<h2><a name="transformalarmc">TransformAlarmC</a></h2>
<p>TransformAlarmC decreases precision and/or widens an Alarm.  An
already widened Counter component is used to help.</p>
<pre class="literal-block">
generic component TransformAlarmC( 
  typedef to_precision_tag,
  typedef to_size_type &#64;integer(),
  typedef from_precision_tag,
  typedef from_size_type &#64;integer(),
  uint8_t bit_shift_right )
{
  provides interface Alarm&lt;to_precision_tag,to_size_type&gt; as Alarm;
  uses interface Counter&lt;to_precision_tag,to_size_type&gt; as Counter;
  uses interface Alarm&lt;from_precision_tag,from_size_type&gt; as AlarmFrom;
}
</pre>
<p>to_precision_tag and to_size_type describe the final precision and
final width for the provided Alarm.  from_precision_tag and
from_size_type describe the precision and width for the source
AlarmFrom.  bit_shift_right describes the bit-shift necessary to
convert from the used precision to the provided precision.</p>
<p>For instance to convert from an Alarm&lt;T32khz,uint16_t&gt; to an
Alarm&lt;TMilli,uint32_t&gt;, the following TransformAlarmC would be
created:</p>
<pre class="literal-block">
new TransformAlarmC( TMilli, uint32_t, T32khz, uint16_t, 5 )
</pre>
</div>
<div class="section" id="transformcounterc">
<h2><a name="transformcounterc">TransformCounterC</a></h2>
<p>TransformCounterC decreases precision and/or widens a Counter.</p>
<pre class="literal-block">
generic component TransformCounterC(
  typedef to_precision_tag,
  typedef to_size_type &#64;integer(),
  typedef from_precision_tag,
  typedef from_size_type &#64;integer(),
  uint8_t bit_shift_right,
  typedef upper_count_type &#64;integer() )
{
  provides interface Counter&lt;to_precision_tag,to_size_type&gt; as Counter;
  uses interface Counter&lt;from_precision_tag,from_size_type&gt; as CounterFrom;
}
</pre>
<p>to_precision_tag and to_size_type describe the final precision and
final width for the provided Counter.  from_precision_tag and
from_size_type describe the precision and width for the source
AlarmFrom.  bit_shift_right describes the bit-shift necessary to
convert from the used precision to the provided precision.
upper_count_type describes the numeric type used to store the
additional counter bits.  upper_count_type MUST be a type with width
greater than or equal to the additional bits in to_size_type plus
bit_shift_right.</p>
<p>For instance to convert from a Counter&lt;T32khz,uint16_t&gt; to a
Counter&lt;TMilli,uint32_t&gt;, the following TransformCounterC would be
created:</p>
<pre class="literal-block">
new TransformCounterC( TMilli, uint32_t, T32khz, uint16_t, 5, uint32_t )
</pre>
</div>
<div class="section" id="virtualizetimerc">
<h2><a name="virtualizetimerc">VirtualizeTimerC</a></h2>
<p>VirtualizeTimerC uses a single Timer to create up to 255 virtual
timers.</p>
<pre class="literal-block">
generic component VirtualizeTimerC( typedef precision_tag, int max_timers )
{
  provides interface Init;
  provides interface Timer&lt;precision_tag&gt; as Timer[ uint8_t num ];
  uses interface Timer&lt;precision_tag&gt; as TimerFrom;
}
</pre>
</div>
</div>
<div class="section" id="platform-dependent-components">
<h1><a name="platform-dependent-components">Platform dependent components</a></h1>
<p>A number of platform dependent components MUST exist:</p>
<ul class="simple">
<li>Alarm32khzC</li>
<li>AlarmMilliC</li>
<li>BusyWait32khzC</li>
<li>BusyWaitMicroC</li>
<li>Counter32khzC</li>
<li>CounterMilliC</li>
<li>TimerMilliC</li>
</ul>
<div class="section" id="alarm32khzc">
<h2><a name="alarm32khzc">Alarm32khzC</a></h2>
<p>Alarm32khzC MUST provide Init and Alarm&lt;T32khz,uint32_t&gt; as
Alarm32khz32.  The configuration MAY provide additional
hardware-specific Alarm interfaces.  Alarm32khzC is a generic
component.  Each instantiation allocates a new, distinct Alarm.
Each instance of an Alarm32khzC MAY directly map to a hardware
timer.</p>
<pre class="literal-block">
generic configuration Alarm32khzC()
{
  provides interface Init;
  provides interface Alarm&lt;T32khz,uint16_t&gt; as Alarm32khz16;
  provides interface Alarm&lt;T32khz,uint32_t&gt; as Alarm32khz32;
}
</pre>
</div>
<div class="section" id="alarmmillic">
<h2><a name="alarmmillic">AlarmMilliC</a></h2>
<p>AlarmMilliC MUST provide Init and Alarm&lt;TMilli,uint32_t&gt; as
AlarmMilli32.  The configuration MAY provide additional
hardware-specific Alarm interfaces.  AlarmMilliC is a generic
component.  Each instantiation allocates a new, distinct Alarm.
Each instance of an AlarmMilliC MAY directly map to a hardware
timer.</p>
<pre class="literal-block">
generic configuration AlarmMilliC()
{
  provides interface Init;
  provides interface Alarm&lt;TMilli,uint32_t&gt; as AlarmMilli32;
}
</pre>
</div>
<div class="section" id="busywait32khzc">
<h2><a name="busywait32khzc">BusyWait32khzC</a></h2>
<p>BusyWait32khzC MUST provide BusyWait&lt;T32khz,uint16_t&gt; as
BusyWait32khz16.  The configuration MAY provide additional
hardware-specific BusyWait interfaces.</p>
<pre class="literal-block">
configuration BusyWait32khzC
{
  provides interface BusyWait&lt;T32khz,uint16_t&gt; as BusyWait32khz16;
}
</pre>
</div>
<div class="section" id="busywaitmicroc">
<h2><a name="busywaitmicroc">BusyWaitMicroC</a></h2>
<p>BusyWaitMicroC MUST provide BusyWait&lt;TMicro,uint16_t&gt; as
BusyWaitMicro16.  The configuration MAY provide additional
hardware-specific BusyWait interfaces.</p>
<pre class="literal-block">
configuration BusyWaitMicroC
{
  provides interface BusyWait&lt;TMicro,uint16_t&gt; as BusyWaitMicro16;
}
</pre>
</div>
<div class="section" id="counter32khzc">
<h2><a name="counter32khzc">Counter32khzC</a></h2>
<p>Counter32khz MUST provide Counter&lt;T32khz,uint32_t&gt; as Counter32khz32
and LocalTime&lt;T32khz&gt; as LocalTime32khz.  The configuration MAY
provide additional hardware-specific Counter interfaces.</p>
<pre class="literal-block">
configuration Counter32khzC
{
  provides interface Counter&lt;T32khz,uint32_t&gt; as Counter32khz32;
  provides interface LocalTime&lt;T32khz&gt; as LocalTime32khz;
}
</pre>
</div>
<div class="section" id="countermillic">
<h2><a name="countermillic">CounterMilliC</a></h2>
<p>CounterMilli MUST provide Counter&lt;TMilli,uint32_t&gt; as CounterMilli32
and LocalTime&lt;TMilli&gt; as LocalTimeMilli.  The configuration MAY
provide additional hardware-specific Counter interfaces.</p>
<pre class="literal-block">
configuration CounterMilliC
{
  provides interface Counter&lt;TMilli,uint32_t&gt; as CounterMilli32;
  provides interface LocalTime&lt;TMilli&gt; as LocalTimeMilli;
}
</pre>
</div>
<div class="section" id="haltimermillic">
<h2><a name="haltimermillic">HalTimerMilliC</a></h2>
<p>HalTimerMilliC MUST provide Init and Timer&lt;TMilli&gt; as
TimerMilli[uint8_t num].  HalTimerMilliC is used by OSKI to
implement the generic component TimerMilliC that allocates a new,
virtual timer with each instantiation.</p>
<pre class="literal-block">
configuration HalTimerMilliC
{
  provides interface Init;
  provides interface Timer&lt;TMilli&gt; as TimerMilli[ uint8_t num ];
}
</pre>
</div>
</div>
<div class="section" id="hardware-differences-between-the-current-platforms">
<h1><a name="hardware-differences-between-the-current-platforms">Hardware differences between the current platforms</a></h1>
<blockquote>
<ol class="loweralpha simple">
<li>Mica2 (ATmega128)</li>
</ol>
<blockquote>
<ol class="lowerroman simple">
<li>Two 8-bit timers, each with</li>
</ol>
<blockquote>
<ul class="simple">
<li>10-bit prescaler</li>
<li>One compare register</li>
</ul>
</blockquote>
<ol class="lowerroman simple" start="2">
<li>Two 16-bit timers, each with</li>
</ol>
<blockquote>
<ul class="simple">
<li>Limited prescalers</li>
<li>Three compare registers</li>
</ul>
</blockquote>
</blockquote>
<ol class="loweralpha simple" start="2">
<li>Telos/EYES (MSP430)</li>
</ol>
<blockquote>
<ol class="lowerroman simple">
<li>Two 16-bit timers with</li>
</ol>
<blockquote>
<ul class="simple">
<li>One with three compare registers</li>
<li>One with eight compare registers</li>
<li>Each from distinct clock source</li>
<li>Each with limited prescalers</li>
</ul>
</blockquote>
</blockquote>
<ol class="loweralpha simple" start="3">
<li>Intel Mote (V2) (Xscale PXA27X)</li>
</ol>
<blockquote>
<ol class="lowerroman simple">
<li>One fixed rate (3.25MHz) 32-bit timer with</li>
</ol>
<blockquote>
<ul class="simple">
<li>4 compare registers</li>
<li>Watchdog functionality</li>
</ul>
</blockquote>
<ol class="lowerroman simple" start="2">
<li>8 variable rate 32-bit timers with</li>
</ol>
<blockquote>
<ul class="simple">
<li>1 associated compare register each</li>
<li>Individually selectable rates: 1/32768s, 1ms, 1s, 1us</li>
<li>Individually selectable sources: (32.768 external osc,
13 Mhz internal clock)</li>
</ul>
</blockquote>
<ol class="lowerroman simple" start="3">
<li>Periodic &amp; one-shot capability</li>
<li>Two external sync events</li>
</ol>
</blockquote>
</blockquote>
</div>
<div class="section" id="platform-specific-mapping">
<h1><a name="platform-specific-mapping">Platform Specific Mapping</a></h1>
<blockquote>
<ol class="loweralpha">
<li><dl class="first docutils">
<dt>Mica2</dt>
<dd><p class="first last">Timer   Size    Clock Source    Usage
-----   ----    ------------    -----
Timer0  8-bit   32khz           Application (TimerMilli)
Timer1  16-bit  CPU (7.4/8MHz)  Not used
Timer2  8-bit   CPU (7.4/8MHz)  Not used
Timer3  16-bit  CPU (7.4/8MHz)  Not used</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Mica2dot</dt>
<dd><p class="first last">Timer   Size    Clock Source    Usage
-----   ----    ------------    -----
Timer0  8-bit   32khz           Application (TimerMilli)
Timer1  16-bit  CPU (4MHz)      Not used
Timer2  8-bit   CPU (4MHz)      Not used
Timer3  16-bit  CPU (4MHz)      Not used</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MicaZ</dt>
<dd><p class="first last">Timer   Size    Clock Source    Usage
-----   ----    ------------    -----
Timer0  8-bit   32khz           Application (TimerMilli)
Timer1  16-bit  CPU (7.4/8MHz)  [CaptureA] CC2420 SFD Pin
Timer2  8-bit   CPU (7.4/8MHz)  CC2420: high resolution (32uSec) timing
Timer3  16-bit  CPU (7.4/8MHz)  Not used</p>
</dd>
</dl>
</li>
</ol>
</blockquote>
</div>
<div class="section" id="implementation">
<h1><a name="implementation">Implementation</a></h1>
<p>For platform independent headers, interfaces, and components, see</p>
<ul class="simple">
<li>tinyos-2.x/tos/lib/timer/</li>
</ul>
<p>For platform dependent implementations, see specific chip
directories, such as</p>
<ul class="simple">
<li>tinyos-2.x/tos/chips/msp430/timer/</li>
<li>tinyos-2.x/tos/chips/ATmega128/timer/</li>
<li>tinyos-2.x/tos/chips/pxa27a/timer/</li>
</ul>
</div>
<div class="section" id="hints">
<h1><a name="hints">Hints</a></h1>
<p>In implementing Alarm32khzC.nc and AlarmMilliC.nc for the MSP430 in
tinyos-2.x/tos/chips/msp430/timer/, see MSP430Timer32khzC.nc and
MSP430Timer32khzMapC.nc for an example of how a set of similar
hardware resources can be exposed through a parameterized interface
for compile-time allocation.  See how Alarm32khzC.nc and
AlarmMilliC.nc call new MSP430Timer32khzC() to allocate a new,
arbitrary hardware timer.  Using this methodology, specific
platforms can override MSP430Timer32khzMapC.nc to remove statically
allocated hardware timers from the set available for compile-time
allocation, such as the Telos platform in
tinyos-2.x/tos/platform/telosa.</p>
</div>
<div class="section" id="author-s-address">
<h1><a name="author-s-address">Author's Address</a></h1>
<div class="line-block">
<div class="line">Cory Sharp</div>
<div class="line">Moteiv Corporation</div>
<div class="line">2168 Shattuck Ave</div>
<div class="line">Berkeley, CA 94704</div>
<div class="line"><br /></div>
<div class="line">email - <a class="reference" href="mailto:cory&#64;moteiv.com">cory&#64;moteiv.com</a></div>
<div class="line"><br /></div>
<div class="line">Martin Turon</div>
<div class="line">P.O. Box 8525</div>
<div class="line">Berkeley, CA 94707</div>
<div class="line"><br /></div>
<div class="line">phone - +1 408 965 3355</div>
<div class="line">email - <a class="reference" href="mailto:mturon&#64;xbow.com">mturon&#64;xbow.com</a></div>
</div>
</div>
</div>
</body>
</html>
