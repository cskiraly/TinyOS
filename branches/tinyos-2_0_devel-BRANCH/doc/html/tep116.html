<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.6: http://docutils.sourceforge.net/" />
<title>Packet Protocols</title>
<meta name="author" content="Philip Levis" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2006-01-15 20:07:27 $
:version: $Revision: 1.1.2.1 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/
body {
  font-family: Times;
  font-size: 16px;
}

.first {
  margin-top: 0 ! important }

.last {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dd {
  margin-bottom: 0.5em }

/* Uncomment (& remove this text!) to get bold-faced definition list terms
dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1 {
  font-family: Arial, sans-serif;
  font-size: 20px;
}

h1.title {
 text-align: center;
 font-size: 32px;
}

h2 {
 font-size: 16px;
 font-family: Arial, sans-serif;
}

h2.subtitle {
  text-align: center }

h3 {
 font-size: 12px;
 font-family: Arial, sans-serif;
}

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em;
}

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap;
  }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<h1 class="title">Packet Protocols</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">116</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Core Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Documentary</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.x</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Philip Levis</td></tr>
<tr class="field"><th class="docinfo-name">Draft-Created:</th><td class="field-body">10-Dec-2004</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Version:</th><td class="field-body">1.1.2.2</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Modified:</th><td class="field-body">2006-01-14</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Discuss:</th><td class="field-body">TinyOS Developer List &lt;tinyos-devel at mail.millennium.berkeley.edu&gt;</td>
</tr>
</tbody>
</table>
<div class="document" id="packet-protocols">
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This memo documents a part of TinyOS for the TinyOS Community, and
requests discussion and suggestions for improvements.  Distribution
of this memo is unlimited. This memo is in full compliance with
TEP 1.</p>
</div>
<div class="section" id="abstract">
<h1><a name="abstract">Abstract</a></h1>
<p>The memo documents the interfaces used by packet protocol components in  
TinyOS 2.x as well as the structure and implementation of ActiveMessageC, 
the basic data-link HIL component. It also documents the virtualized
active message interfaces AMSender and AMReceiver.</p>
</div>
<div class="section" id="introduction">
<h1><a name="introduction">1. Introduction</a></h1>
<p>Sensor nodes are network-centric devices. Much of their software
complexity comes from network protocols and their interactions.
In TinyOS, the basic network abstraction is an <em>active message</em>,
a single-hop, unreliable packet. Active messages have a destination
address, provide synchronous acknowledgements, and can be of
variable length up to a fixed maximum size. They also have a 
type field, which is essentially a protocol identifier for
components built on top of this abstraction.</p>
<p>In TinyOS 1.x, the component GenericComm provides interfaces for
transmitting and receiving active messages:</p>
<pre class="literal-block">
configuration GenericComm {
  provides {
    interface StdControl as Control;
    interface SendMsg[uint8_t id];
    interface ReceiveMsg[uint8_t id];
    command uint16_t activity();
  }
  uses {
    event result_t sendDone();
  }
}
</pre>
<p>This component, while simple, has several issues. First, it has the
activity() event, which does not have a single caller in the entire
TinyOS tree. This command requires GenericComm to allocate a 
timer, wasting CPU cycles and RAM.</p>
<p>Second, it does not allow a node to receive packets besides
those destined to it.  Several network
protocols (e.g., MintRoute, PSFQ, TAG) take advantage of snooping
on these packets for a variety of improvements in efficiency or
performance. This has led to the creation of GenericCommPromiscuous,
whose Receive interface does not distinguish
between packets received that were addressed to the node and
packets received that were addressed to other nodes. Choosing
one of the two implementations is a global decision across
an application. There is a way to enable both reception
semantics at the same time for a different protocols, 
but they require a creative use of default event handlers.</p>
<p>Third, it assumes that components will directly access the packet
structure, the accepted approach in TinyOS 1.x. However, directly
accessing packet structures introduces unforseen dependencies:
a component that names a header field, for example, binds itself
to data link layers that have a field with that name. Similarly,
components on top of GenericComm directly access the data payload
of a packet.</p>
<p>TEP 111 documents the structure of a TinyOS 2.x packet buffer[_tep111].
This TEP documents the interfaces used to access packet buffers,
as well as ActiveMessageC, the basic data-link packet communication
HIL.</p>
</div>
<div class="section" id="communication-interfaces">
<h1><a name="communication-interfaces">2. Communication interfaces</a></h1>
<p>Packet-level communication has three basic classes of interfaces.
<em>Packet</em> interfaces are for accessing message fields and payloads. 
The <em>Receive</em> interface is for handling packet reception events.
Finally, <em>Send</em> interfaces are for transmitting packets, and are
distinguished by their addressing scheme.</p>
<div class="section" id="packet-interfaces">
<h2><a name="packet-interfaces">2.1 Packet interfaces</a></h2>
<p>The basic TinyOS 2.x message buffer type is message_t, which is 
described in TEP 111. message_t right-justifies data-link
headers to the data payload so that higher-level components can 
pass buffers between different data link layers without having
to move data payloads. This means that the data payload of a 
data link frame is always at a fixed offset of a message_t.</p>
<p>Once protocols layer on top of each other, the data
payload for components on top of the data link layer are
no longer at a fixed offset. Where a component can put its 
header or data depends on what headers underlying components
introduce. Therefore, in order to be able to find out where
it can put its data, it must query the components below it.
The Packet interface defines this mechanism:</p>
<pre class="literal-block">
interface Packet {
  command void clear(message_t* msg);
  command uint8_t payloadLength(message_t* msg);
  command uint8_t maxPayloadLength();
  command void* getPayload(message_t* msg, uint8_t* len);
}
</pre>
<p>A component can obtain a pointer to its data region within
a packet by calling <tt class="docutils literal"><span class="pre">getPayload()</span></tt> the optional <tt class="docutils literal"><span class="pre">len</span></tt> argument
is for also obtaining the size of the data region. A provider
of a Packet interface MUST check if <tt class="docutils literal"><span class="pre">len</span></tt> is NULL and ignore it
if it is. A component can also obtain the size of the data region
with a call to <tt class="docutils literal"><span class="pre">payloadLength</span></tt>.</p>
<p>The distinction between <tt class="docutils literal"><span class="pre">payloadLength</span></tt> and <tt class="docutils literal"><span class="pre">maxPayloadLength</span></tt>
comes from whether the packet is being received or sent. In the former
case, determining the size of the existing data payload is needed;
in the latter case, the size of the payload last put in the packet
is usually not as relevant as the size of the payload a component can
put in it. Setting the payload length of a packet is done with a sending 
operation, and is outside the scope of the Packet interface.</p>
<p>The Packet interface assumes that headers have a fixed size. 
It is difficult to return a pointer into the data region when its 
position will only be known once the header values are bound.</p>
<p>Generally, an incoming call to the Packet interface of a protocol
has an accompanying outgoing call to the Packet interface of the 
component below it. The one exception to this is the data link
layer. For example, if there is a network that introduces
16-bit sequence numbers to packets, it might look like this:</p>
<pre class="literal-block">
generic module SequenceNumber {
  provides interface Packet;
  uses interface Packet as SubPacket;
}
implementation {
  typedef nx_struct seq_header {
    nx_uint16_t seqNo;
  } seq_header_t;

  enum {
    SEQNO_OFFSET = sizeof(seq_header_t),
  };

  command void Packet.clear(message_t* msg) {
    uint8_t len;
    void* payload = call SubPacket.getPayload(msg, &amp;len);
    memset(payload, len, 0);
  }

  command uint8_t Packet.payloadLength(message_t* msg) {
    return SubPacket.payloadLength(msg) - SEQNO_OFFSET;
  }

  command uint8_t Packet.maxPayloadLength() {
    return SubPacket.maxPayloadLength(msg) - SEQNO_OFFSET;
  }

  command void* Packet.getPayload(message_t* msg, uint8_t* len) {
    uint8_t* payload = call SubPacket.getPayload(msg, len);
    if (len != NULL) {
      *len -= SEQNO_OFFSET;
    }
    return payload + SEQNO_OFFSET; 
  } 
}
</pre>
<p>The above example is incomplete: it does not include the code for
the send path that increments sequence numbers.</p>
<p>In practice, calls to Packet are very efficient even if they 
pass through many components before reaching the data link
layer. nesC's inlining means that in almost all cases
there will not actually be any function calls, and since payload
position and length calculations all use constant offsets,
the compiler generally uses constant folding to generate a 
fixed offset.</p>
<p>The Packet interface provides access to the one field all packet
layer have, the data payload. Communication layers can add additional
header and footer fields, and may need to provide access to these
fields. If a packet communication component provides access to header
and/or footer fields, it MUST do so through an interface. The interface 
SHOULD have a name of the form <em>X*Packet, where *X</em> is a name that
describes the communication layer. For example, active message components
provide both the Packet interface and the AMPacket interface. The latter
has this signature:</p>
<pre class="literal-block">
interface AMPacket {
  command am_addr_t address();
  command am_addr_t destination(message_t* amsg);
  command bool isForMe(message_t* amsg);
  command am_id_t type(message_t* amsg);
}
</pre>
<p>The command address() returns the local AM address of the node. AMPacket
provides accessors for its two fields, destination and type. It does
not provide commands to set these fields, as they are set in the 
sending call path (see Section 2.3).</p>
</div>
<div class="section" id="receive-interface">
<h2><a name="receive-interface">2.2 Receive interface</a></h2>
<p>Receive is the interface for receiving packets. It has this signature:</p>
<pre class="literal-block">
interface Receive {
  event message_t* receive(message_t* msg, void* payload, uint8_t len);
}
</pre>
<p>The <tt class="docutils literal"><span class="pre">payload</span></tt> parameter MUST be identical to what a call to 
<tt class="docutils literal"><span class="pre">Packet.getPayload()</span></tt> would return, and the <tt class="docutils literal"><span class="pre">len</span></tt> parameter MUST
be identical to the length that a call to <tt class="docutils literal"><span class="pre">Packet.getPayload()</span></tt>
would return. These parameters are for convenience, as they are commonly 
used by receive handlers, and their presence removes the need for
a call to <tt class="docutils literal"><span class="pre">Packet.getPayload()</span></tt>.</p>
<p>Receive has a <em>buffer-swap</em> policy. The handler of the event MUST return
a pointer to a valid message buffer for the signaler to use. This
approach enforces an equilibrium between upper and lower packet 
layers. If an upper layer cannot handle packets as quickly as they
are arriving, it still has to return a valid buffer to the lower
layer. This buffer could be the <tt class="docutils literal"><span class="pre">msg</span></tt> parameter passed to it: it
just returns the buffer it was given without looking at it. Following
this policy means that a data-rate mismatch in an upper-level component 
will be isolated to that component. It will drop packets, but it will
not prevent other components from receiving packets. If an upper
layer did not have to return a buffer immediately, then when an
upper layer cannot handle packets quickly enough it will end up
holding all of them, starving lower layers and possibly preventing
packet reception.</p>
<p>A <em>user</em> of the Receive interface has three basic options when it
handles a receive event:</p>
<ol class="arabic simple">
<li>Return <tt class="docutils literal"><span class="pre">msg</span></tt> without touching it.</li>
<li>Copy some data out of <tt class="docutils literal"><span class="pre">payload</span></tt> and return <tt class="docutils literal"><span class="pre">msg</span></tt>.</li>
<li>Store <tt class="docutils literal"><span class="pre">msg</span></tt> in its local frame and return a different <tt class="docutils literal"><span class="pre">message_t*</span></tt> for the lower layer to use.</li>
</ol>
<p>These are simple code examples of the three cases:</p>
<pre class="literal-block">
// Case 1
message_t* Receive.receive(message_t* msg, void* payload, uint8_t len) {
  return msg; 
}  

// Case 2
uint16_t value;
message_t* Receive.receive(message_t* msg, void* payload, uint8_t len) {
  if (len &gt;= sizeof(uint16_t)) {
    nx_uint16_t* nval = (nx_uint16_t*)payload;
    value = *nval;
  }
  return msg;
}

//Case 3
message_t* ptr;
message_t* Receive.receive(message_t* msg, void* payload, uint8_t len) {
  message_t* tmp = ptr;
  ptr = msg;
  post processTask();
  return tmp;
}
</pre>
<p>Because of case 3), a lower layer MUST respect the buffer swap semantics
and use the pointer returned from <tt class="docutils literal"><span class="pre">receive</span></tt>. The pointer passed as
a parameter to <tt class="docutils literal"><span class="pre">receive</span></tt> MUST NOT be touched, used, or stored after
the signaling of <tt class="docutils literal"><span class="pre">receive.</span></tt></p>
</div>
<div class="section" id="sending-interfaces">
<h2><a name="sending-interfaces">2.3 Sending interfaces</a></h2>
<p>There are multiple sending interfaces, corresponding to different
addressing modes. For example, address-free protocols, such as
collection routing, provide the basic <tt class="docutils literal"><span class="pre">Send</span></tt> interface. Active
message communication has a destination of an AM address, so
it provides the <tt class="docutils literal"><span class="pre">AMSend</span></tt> interface.  This, for example, is the 
basic, address-free Send interface:</p>
<pre class="literal-block">
interface Send {
  command error_t send(message_t* msg, uint8_t len);
  command error_t cancel(message_t* msg);
  event void sendDone(message_t* msg, error_t error);  

  command uint8_t maxPayloadLength();
  command void* getPayload(message_t* msg);
}
</pre>
<p>while this is the AMSend interface:</p>
<pre class="literal-block">
interface AMSend {
  command error_t send(am_addr_t addr, message_t* msg, uint8_t len);
  command error_t cancel(message_t* msg);
  event void sendDone(message_t* msg, error_t error);

  command uint8_t maxPayloadLength();
  command void* getPayload(message_t* msg); 
}
</pre>
<p>Sending interfaces MUST include these four commands and one event.
The duplication of some of the commands in Packet is solely
for ease of use: <tt class="docutils literal"><span class="pre">maxPayloadLength</span></tt> and <tt class="docutils literal"><span class="pre">getPayload</span></tt> MUST
behave identically as <tt class="docutils literal"><span class="pre">Packet.maxPayloadLength</span></tt> and
<tt class="docutils literal"><span class="pre">Packet.getPayload</span></tt>. Their inclusion is so that components
do not have to wire to both Packet and the sending interface for
basic use cases.</p>
</div>
</div>
<div class="section" id="hil-activemessagec">
<h1><a name="hil-activemessagec">3. HIL: ActiveMessageC</a></h1>
<p>A platform MUST provide ActiveMessageC as a basic HIL to 
packet-level communication.  ActiveMessageC provides a best-effort, 
single-hop communication abstraction.  Every active message has a 
16-bit destination address and an 8-bit type. There is one reserved 
destination address, <tt class="docutils literal"><span class="pre">AM_BROADCAST_ADDR</span></tt>, which has the value 
of <tt class="docutils literal"><span class="pre">0xffff</span></tt>. ActiveMessageC has the following signature:</p>
<pre class="literal-block">
configuration ActiveMessageC {
  provides {
    interface Init;
    interface SplitControl;  

    interface AMSend[uint8_t id];
    interface Receive[uint8_t id];
    interface Receive as Snoop[uint8_t id];

    interface Packet;
    interface AMPacket;
    interface PacketAcknowledgements;
  }
}
</pre>
<p>The Receive interface is for packets destined to the node, while 
the Snoop interface is for packets destined to other nodes. A 
packet is destined for a node if its destination AM address is 
either the AM broadcast address or an address associated with 
the AM stack. Different link layers have different snooping 
capabilities. The Snoop interface does not assume always-on 
listening, for example, in the case of a TDMA or RTS/CTS data 
link layer. By separating out these two interfaces, ActiveMessageC
avoids the complications encountered in 1.x with regards to
GenericComm vs. GenericCommPromiscuous.</p>
<p>ActiveMessageC is usually just a configuration that has
pass-through wiring to a chip-specific HAL active message
implementation. The definition of ActiveMessageC is left
to the platform for when a node has more than one
radio. In this case, the platform decides how to map the
basic packet abstraction to the hardware underneath. Approaches 
include choosing one radio or having some form of address-based
dispatch.</p>
</div>
<div class="section" id="services-amsenderc-amreceiverc-amsnooperc-amsnoopingreceiverc">
<h1><a name="services-amsenderc-amreceiverc-amsnooperc-amsnoopingreceiverc">4. Services: AMSenderC, AMReceiverC, AMSnooperC, AMSnoopingReceiverC</a></h1>
<p>TinyOS 2.x provides four component virtualizations to applications:
AMReceiverC, AMSnooperC, AMSnoopingReceiverC, and AMSenderC. Each is a
generic component that takes an active message ID as a
parameter. These components assume the existence of ActiveMessageC.</p>
<div class="section" id="amreceiverc">
<h2><a name="amreceiverc">4.1 AMReceiverC</a></h2>
<p>AMReceiverC has the following signature:</p>
<pre class="literal-block">
generic configuration AMReceiverC(am_id_t t) {
  provides{
    interface Receive;
    interface Packet;
    interface AMPacket;
  }
}
</pre>
<p>AMReceiver.Receive.receive is signalled whenever the packet layer
receives an active message of the corresponding AM type whose
destination address is the local address or the broadcast
address. Note that since Receive.receive swaps buffers, a program MUST
NOT instantiate two AMReceivers with the same am_id_t and MUST NOT
instantiate an AMReceiver and an AMSnoopingReceiver with the same
am_id_t.</p>
</div>
<div class="section" id="amsnooperc">
<h2><a name="amsnooperc">4.2 AMSnooperC</a></h2>
<p>AMSnooper has an identical signature to AMReceiver:</p>
<pre class="literal-block">
generic configuration AMSnooperC(am_id_t t) {
  provides{
    interface Receive;
    interface Packet;
    interface AMPacket;
  }
}
</pre>
<p>AMSnooper.Receive.receive is signalled whenever the packet layer
receives an active message of the corresponding AM type whose
destination address is neither to the local address nor the broadcast
address. Note that since Receive.receive swaps buffers, a program MUST
NOT instantiate two AMSnoopers with the same am_id_t and MUST NOT
instantiate an AMSnooper and an AMSnoopingReceiver with the same
am_id_t.</p>
</div>
<div class="section" id="amsnoopingreceiverc">
<h2><a name="amsnoopingreceiverc">4.3 AMSnoopingReceiverC</a></h2>
<p>AMSnoopingReceiver has an identical signature to AMReceiver:</p>
<pre class="literal-block">
generic configuration AMSnoopingReceiverC(am_id_t t) {
  provides{
    interface Receive;
    interface Packet;
    interface AMPacket;
  }
}
</pre>
<p>AMSnoopingReceiver.Receive.receive is signalled whenever the packet
layer receives an active message of the corresponding AM type,
regardless of destination address. Note that since Receive.receive
swaps buffers, a program that instantiates an AMSnoopingReceiver with
a certain am_id_t MUST NOT instantiate another AMSnoopingReceiver,
AMSnooper, or AMReceiver with the same am_id_t.</p>
</div>
<div class="section" id="amsender">
<h2><a name="amsender">4.4 AMSender</a></h2>
<p>AMSender has the following signature:</p>
<pre class="literal-block">
generic configuration AMSenderC(am_id_t AMId) {
  provides {
    interface AMSend;
    interface Packet;
    interface AMPacket;
    interface PacketAcknowledgements as Acks;
  }
}
</pre>
<p>Because this is a send virtualization, AMSenderC.AMSend.send returns
EBUSY only if there is a send request outstanding on this particular
AMSenderC. That is, each AMSenderC has a queue of depth one. The exact
order in which pending AMSenderC requests are serviced is undefined,
but it MUST be fair queueing.</p>
</div>
<div class="section" id="power-management">
<h2><a name="power-management">4.5 Power Management</a></h2>
<p>The communication virtualizations do not support power management.
That is left to components interacting directly with ActiveMessageC.</p>
</div>
</div>
<div class="section" id="hal-requirements">
<h1><a name="hal-requirements">5. HAL Requirements</a></h1>
<p>A radio chip <strong>X</strong> MUST have a packet abstraction with the following
signature:</p>
<pre class="literal-block">
provides interface Init;
provides interface SplitControl;
provides interface AMSend[am_id_t type];
provides interface Receive[am_id_t type];
provides interface Receive as Snoop[am_id_t type];
provides interface Packet;
provides interface AMPacket;
provides interface PacketAcknowledgments;
</pre>
<p>The component SHOULD be named <strong>X**ActiveMessageC, where **X</strong> is 
the name of the radio chip. The component MAY have additional interfaces. 
These interfaces can either be chip-specific or chip-independent.</p>
</div>
<div class="section" id="message-t">
<h1><a name="message-t">6. message_t</a></h1>
<p>Active messages are a basic single-hop packet abstraction. Therefore,
following TEP 111[_tep111], all data link and active message headers
MUST be in the <tt class="docutils literal"><span class="pre">radio_header_t</span></tt> structure of message_t. This ensures
that an active message received from one data link layer (e.g., the radio)
can be passed to another data link layer (e.g., the UART) without
shifting the data payload. This means that the <tt class="docutils literal"><span class="pre">radio_header_t</span></tt> must
include all data needed for AM fields, which might introduce headers
in addition to those of the data link. For example, this is the 
structure of the CC2420 header:</p>
<pre class="literal-block">
typedef nx_struct cc2420_header_t {
  nx_uint8_t length;
  nx_uint16_t fcf;
  nx_uint8_t dsn;
  nx_uint16_t destpan;
  nx_uint16_t dest;
  nx_uint16_t src;
  nx_uint8_t type;
} cc2420_header_t;
</pre>
<p>The first six fields (length through src) are all 802.15.4 headers. The
type field, however, has been added to the header structure in order
to support AM dispatch.</p>
</div>
<div class="section" id="author-s-address">
<h1><a name="author-s-address">7. Author's Address</a></h1>
<div class="line-block">
<div class="line">Philip Levis</div>
<div class="line">358 Gates Hall</div>
<div class="line">Computer Science Laboratory</div>
<div class="line">Stanford University</div>
<div class="line">Stanford, CA 94305</div>
<div class="line"><br /></div>
<div class="line">phone - +1 650 725 9046</div>
</div>
</div>
<div class="section" id="citations">
<h1><a name="citations">7. Citations</a></h1>
<table class="docutils citation" frame="void" id="tep111" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="tep111">[tep111]</a></td><td>TEP 111: message_t.</td></tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
