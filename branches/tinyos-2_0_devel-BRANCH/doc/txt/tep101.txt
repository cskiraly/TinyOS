===================================
Analog-to-Digital Converters (ADCs)
===================================

:TEP: 101
:Group: Core Working Group 
:Type: Documentary
:Status: Draft
:TinyOS-Version: 2.x
:Authors: Jan-Hinrich Hauer, Philip Levis, Vlado Handziski, David Gay

:Draft-Created: 20-Dec-2004
:Draft-Version: $Revision: 1.1.2.2 $
:Draft-Modified: $Date: 2006-01-05 14:35:39 $
:Draft-Discuss: TinyOS Developer List <tinyos-devel at mail.millennium.berkeley.edu>

.. Note::

   This memo documents a part of TinyOS for the TinyOS Community, and
   requests discussion and suggestions for improvements.  Distribution
   of this memo is unlimited. This memo is in full compliance with
   TEP 1.


Abstract
====================================================================

This TEP proposes a hardware abstraction for TinyOS 2.x analog-to-digital
converters (ADCs). It focuses on aligning the ADC abstraction with the
three-layer Hardware Abstraction Architecture (HAA) described in TEP 2, but
addresses only the HPL and HAL, because the highest level abstraction of an
ADC is platform-dependent.

1. Introduction
====================================================================

Analog-to-digital converters (ADCs) are devices that convert analog input
signals to discrete digital output signals, typically voltage to a digital
number.  The interested reader can refer to Appendix A for a brief overview of
the ADC hardware on some current TinyOS platforms.  In earlier versions of
TinyOS, the distinction between a sensor and an ADC were blurred: this led
components that had nothing to do with an ADC to still resemble one
programatically, even though the semantics and forms of operation were
completely different.  To compensate for the difference non-ADC sensors
introduced additional interfaces, such as ADCError, that were tightly bound to
sensor acquisition but separate in wiring. The separation between the ADC and
ADCError interface is bug prone and problematic, as is the equation of a
sensor and an ADC. TinyOS 2.x separates the structure and interfaces of an ADC
from those of sensors (which may be on top of an ADC, but this fact is hidden
from higher level components). This TEP presents how TinyOS 2.x decomposes and
structures ADC software. TEP 109 (Sensor Boards) shows how a platform can
present actual named sensors [_tep109].

As can be seen in Appendix A the ADC hardware used on TinyOS platforms differ
in many respects, which makes it difficult to find a chip independent
representation for an ADC. Even if there were such a representation, the
configuration details of an ADC would still depend on the actual device
producing the input signal (sensor).  Neither a platform independent
application nor the ADC hardware stack itself has access to this information,
as it can only be determined on a platform or sensorboard level. For example,
determining which ADC port a sensor is attached to and how a conversion result
is to be interpreted is a platform-specific determination. 

In spite of their hardware differences, one aspect represents a common
denominator of all ADCs: they produce conversion results. In order to
facilitate sensor software development this capability can be made available
via chip-independent interfaces for every ADC. However, conversion results
depend on and have to be interpreted with respect to the platform-specific
configuration settings (the ADC channel, the applied reference voltage, etc.).
Therefore the highest level of ADC abstraction consists of
platform-independent interfaces for ADC data collection and chip-specific
interfaces for ADC hardware configuration.  The top ADC layer thus remains
platform-dependent and consequently the ADC abstraction does not include an
HIL, but ends with the HAL. Following the principles of the HAA[_tep2] the HAL
of an ADC should also expose the chip-specific capabilities for ADC data
collection. For example, the ADC12 on the msp430 supports a complex repeated
conversion mode for a set of different input channels, which is too specific
to be represented by a platform-independent data collection interface.
Therefore the HAL of an ADC abstraction is broken into two sublayers: The
bottom HAL layer, called HAL1, exposes the full capabilities of the respective
ADC in a chip-specific way. It realizes the standard HAL in the HAA[_tep2] and
the HPL lies below it.  On top of the HAL1 sits the HAL2 which maps the
interfaces it uses from HAL1 to a set of platform-independent interfaces for
data collection and chip-specific configuration interfaces.

The rest of this TEP specifies:

* the set of platform-independent interfaces for the collection of ADC
  conversion results (`2. Interfaces`_)
* guidelines on how an ADC's HAL SHOULD should be split into HAL1 and HAL2 and
  how the HAL1 SHOULD expose chip-specific interfaces (`3. HAL1 guidelines`_)
* what component an ADC's HAL2 MUST implement (`4. HAL2 requirements`_)
* a set of utility components which simplify usage of the HAL2 components
  (`5. Utility components`_)

This TEP ends with appendices documenting, as an example, the msp430
ADC subsystem implementation.


2. Interfaces
====================================================================

This TEP proposes to adopt the following three generic, source-independent
data collection interfaces from the SID TEP [_tep?] for the collection of ADC
conversion results::

  interface Read< size_type >
  interface ReadNow< size_type >
  interface ReadStream< size_type >

Every data collection interface is associated with its individual
chip-specific configuration settings (e.g. input channel, sample-hold-time,
etc.).  How this association SHOULD be realized is explained in Section `4.
HAL2 requirements`_. As the resolution of conversion results is chip-specific,
the 'size_type' parameter reflects an upper bound for the chip-specific
resolution of the conversion results - the actual resolution may be smaller,
depending on the ADC and/or data source (e.g.  uint16_t for a 12-bit ADC). The
above interfaces are specified in the SID TEP [_tep?], in the following their
usage is explained with respect to ADCs.

Read
--------------------------------------------------------------------

The Read interface can be used to sample an ADC channel and return a single
conversion result. It provides no guarantees about when exactly the sampling
of the ADC channel is performed (the request may be buffered). 

ReadNow
--------------------------------------------------------------------

The ReadNow interface is similar to the Read interface, but provides more
precise control over the exact point of time of the sampling. If
ReadNow.read() succeeds, the ADC starts to sample the channel immediately (the
request is not buffered).

ReadStream
--------------------------------------------------------------------

The ReadStream interface can be used to sample an ADC channel multiple times
with a specified sampling period. It provides no guarantees about when exactly
the first sampling of the ADC channel starts, but all subsequent samplings
occur with the specified sampling period.


3. HAL1 guidelines
====================================================================

As explained in `1. Introduction`_ the HAL of an ADC abstraction consists of
two sublayers, HAL1 and HAL2. In the ADC component stack the HAL1 resides
below HAL2 and above the HPL. It exposes the full capabilities of the ADC in a
chip-specific way and has the same function as the 'traditional' HAL in the
HAA[_tep2]. Although the HAL1 is chip-specific both in terms of implementation
and representation, its design SHOULD follow the guidelines described below to
facilitate the mapping to platform-independent interfaces on the level of HAL2
and above. Only chip- and platform-dependent clients MAY wire to the HAL1.
Appendix B shows the HAL1 contents for the TI MSP430 MCU.

Resource reservation
--------------------------------------------------------------------

As the ADC hardware is a shared resource that is multiplexed between several
clients, it requires access arbitration. Therefore the HAL1 configuration
component SHOULD provide the 'Init' and a parameterized 'Resource' interface,
instantiate a generic arbiter component and wire both interfaces to the
arbiter as described in TEP 108 [_tep108]. The ADC utility components (see
Section `5.  Utility components`_) use a library of standard TinyOS resource
management components and assume arbitration of the ADC in round robin
fashion. Therefore the HAL1 SHOULD instantiate the standard round robin
arbiter.

Configuration and sampling
--------------------------------------------------------------------

As the ADC hardware is a shared resource the HAL1 SHOULD support hardware
configuration and sampling on a per-client basis (although per-port
configuration is possible, it is not recommended, because it forces all
clients to use the same settings for a given port). Therefore an HAL1 SHOULD
provide one (or more) parameterized "sampling interfaces", which export access
to the ADC hardware configuration, start the sampling process and signal
conversion results. A client wires to an instance of the parameterized
sampling interface with a unique client identifier. All commands and events
SHOULD be 'async' to reflect the potential timing requirements of clients. An
HAL1 MAY provide multiple different parameterized sampling interface,
depending the hardware capabilities. This allows to differentiate/group ADC
functions, for example single vs.  repeated sampling, single channel vs.
multiple channels or low-frequency vs.  high-frequency sampling.  Every
sampling interface SHOULD allow the client to individually configure the ADC,
for example by including the configuration settings as parameters in the
sampling commands. However, if configuration settings are passed as a pointer,
the HAL1 component MUST NOT reference it after the return of the respective
command (see Appendix B for an example).

For example, the HAL1 for an ADC that supports the sampling of a single and of
multiple channels may provide two parameterized interfaces, one for
single-channel access and one to access multiple channels. Each interface
includes 'getData()' commands which take the configuration settings as a
parameter and 'dataReady()' events signal conversion results to the respective
client.


HAL1 generic wrappers
--------------------------------------------------------------------

In order to hide wiring complexities and/or export only a subset of all ADC
functions (e.g. only access to multiple channels) generic ADC wrapper
components MAY be provided on the level of HAL1 to be instantiated by chip-
and platform-dependent clients.


4. HAL2 requirements
====================================================================

Every platform with an A/D converter MUST provide a component AdcC::

   configuration AdcC {
     provides {
       interface Init;
       interface StdControl;
       interface Resource[uint8_t client];
       interface Read< size_type > as Read[uint8_t client];
       interface ReadNow< size_type > as ReadNow[uint8_t client];
       interface ReadStream< size_type > as ReadStream[uint8_t client];
     }
     uses {
       // chip-dependent configuration interface
     }
   }

The chip-dependent 'size_type' parameter represents the maximum possible
resolution of a conversion result. In its implementation part the AdcC SHOULD
wire the 'Resource' and 'Init' interfaces to the HAL1 and the data collection
interfaces to the HAL2 implementation. The AdcC component also needs a way to
determine a client's ADC settings (the data collection interfaces do not
include ADC configuration). This is discussed in the following section.

Configuration
--------------------------------------------------------------------

The AdcC component SHOULD *use* a parameterized chip-dependent configuration
interface to retrieve the ADC configuration settings for a given client. That
means a client of the HAL2 will not only wire to the 'Resource' and data
collection interfaces, but it SHOULD also wire the chip-dependent
configuration interface of the HAL2 to a component that returns the respective
ADC settings. The client MUST instantiate all interfaces with the same unique
client id. The configuration interface can, for example, include only a single
command, which returns the respective client's configuration settings and the
HAL2 implementation SHOULD call the command to determine the respective ADC
settings every time the client requests ADC data.  The typical sequence of
events is as follows: After a client has been granted access to the ADC via
the 'Resource' interface it may call a data collection command, for example
Read.read(). The HAL2 implementation will then 'pull' the client's ADC
configuration settings: it calls the respective command in the chip-dependent
configuration interface using the client identifier as the interface
parameter.  With the help of the pulled configuration settings the HAL2
implementation can translate the Read.read() call to a chip-specific HAL1
command and forward the conversion result to the client.

Note that, although the *provided* interfaces are platform independent, the
fact that the HAL2 *uses* a chip-dependent configuration interface and the
fact that the provided data-collection interfaces are parameterized by a
client identifier that maps to the respective configuration settings makes the
HAL2 representation platform dependent. However, separating the ADC
configuration settings from the data collection interfaces makes it possible
to provide platform independent interfaces for ADC data collection. It also
enables utility library components to sit on top of HAL2 and thus simplifies
sensor driver development.

A platform designer is encouraged to write a separate configuration component
for every device connected to the ADC. This component should provide the
ADC-dependent configuration interface and return the configuration settings
for the device.  Appendix C shows an example of how such a component can
provide multiple different configuration settings for the same device (e.g.
for high- or low-frequency sampling).

5. Utility components
====================================================================

The following platform independent ADC utility components are built on top of
the HAL2 to facilitate access to the ADC system:

* AdcReadClient 
* AdcReadNowClient 
* AdcReadStreamClient 

These generic components provide single interfaces for data collection and
hide the arbitration complexities from the client components. A component
instantiating such a generic component MUST use a unique client identifier
created with 'unique(ADC_CLIENT)' and establish the mapping between the AdcC
component and the component that provides the client's ADC configuration
settings. It MUST use the same client identifier for both (Appendix C shows an
example).

AdcReadClient
--------------------------------------------------------------------

generic configuration AdcReadClient( uint8_t client_id, typedef size_type ) {
  provides interface Read<size_type>;
}

AdcReadNowClient
--------------------------------------------------------------------

generic configuration AdcReadNowClient( uint8_t client_id, typedef size_type ) {
  provides interface ReadNow<size_type>;
}

AdcReadStreamClient
--------------------------------------------------------------------

generic configuration AdcReadStreamClient( uint8_t client_id, typedef size_type ) {
  provides interface ReadStream<size_type>;
}

Appendix A: Hardware differences between platforms
====================================================================

The TI MSP430 and the Atmel ATmega 128 are two common microcontrollers used in
TinyOS platforms. They both have integrated ADCs, which have different
functionality and capabilities. These distinctions illustrate the complexities
that prevent ADCs from having a truly hardware independent abstraction. The
following table compares the characteristics of the two microcontrollers:

+----------------------+----------------------+---------------------+
|                      | Atmel Atmega 128     | TI MSP430 ADC12     |
+======================+======================+=====================+
|Resolution            | 10-bit               | 12-bit              |
+----------------------+----------------------+---------------------+
|channels              |- 8 multiplexed       |- 8 individually     |
|                      |  external channels   |  configurable       |
|                      |- 16 differential     |  external channels  |
|                      |  voltage input       |- internal channels  |
|                      |  combinations        |  (AVcc, temperature,|
|                      |- 2 differential      |  reference voltages)|
|                      |  inputs with gain    |                     |
|                      |  amplification       |                     |
+----------------------+----------------------+---------------------+
|internal reference    | 2.56V                | 1.5V or 2.5V        |
|voltage               |                      |                     |
+----------------------+----------------------+---------------------+
|conversion reference  |- positive terminal:  | individually        |
|                      |  AVcc or 2.56V  or   | selectable per      |
|                      |  AREF (external)     | channel:            |
|                      |- negative terminal:  |                     |
|                      |  GND                 |- AVcc and AVss      |
|                      |                      |- Vref+ and AVss     |
|                      |                      |- Veref+ and AVss    |
|                      |                      |- AVcc and (Vref- or |
|                      |                      |  Veref-)            |
|                      |                      |- AVref+ and (Vref-  |
|                      |                      |  or Veref-)         |
|                      |                      |- Veref+ and (Vref-  |
|                      |                      |  or Veref-)         |
+----------------------+----------------------+---------------------+
|conversion modes      |- single channel      |- single conversion  |
|                      |  conversion mode     |  mode               |
|                      |- free running mode   |- repeat single      |
|                      |  (channels and       |  conversion mode    |
|                      |  reference voltages  |- sequence mode      |
|                      |  can be switched     |  (sequence <= 16    |
|                      |  between samples)    |  channels)          |
|                      |                      |- repeat sequence    |
|                      |                      |  mode               |
+----------------------+----------------------+---------------------+
|conversion clock      |clkADC with prescaler |ACLK, MCLK, SMCLK or |
|source                |                      |ADC-oscillator (5MHz)|
|                      |                      |with prescaler       |
|                      |                      |respectively         |
+----------------------+----------------------+---------------------+
|sample-hold-time      |1.5 clock cycles      |selectable values    |
|                      |(fixed)               |from 4 to 1024 clock |
|                      |                      |cycles               |
+----------------------+----------------------+---------------------+
|conversion triggering |by software           |by software or timers|
+----------------------+----------------------+---------------------+
|conversion during     |yes                   |yes                  |
|sleep mode possible   |                      |                     |
+----------------------+----------------------+---------------------+
|interrupts            |after each conversion |after single or      |
|                      |                      |sequence conversion  |
+----------------------+----------------------+---------------------+


Appendix B: an ADC: MSP430 ADC12
====================================================================

(TODO)

Appendix C: a mote: eyesIFX ADC abstraction
====================================================================

This section presents the ADC component stack on the 'eyes' platform (using
the TI MSP430 MCU). The ADC abstraction ends with utility components located
on top of HAL2, but for a complete understanding the example shows a component
graph that includes a sensor driver connected to the ADC stack. Typically the
layer above the utility components is composed of named sensor components that
provide interfaces for collecting the sensor data as described in [tep109]_.

Component stack
--------------------------------------------------------------------

The following example is a (partial) depiction of the ADC component stack on
the 'eyes' platform. It shows how the photo sensor component is connected to
the ADC stack (but omits the component that encapsulates the sensor
configuration settings).::


                   +-------------+
                   | Application |
                   +-------------+
                          ^
                          |
                        Read
                          |
                   +--------------------+ 
                   |  PhotoSensorC      |  
     Sensor        | (wires AdcC to the |  location: tinyos-2.x/tos/platforms/eyes
    Wrapper:       |  sensor configu-   |
                   |  ration component) |
                   +--------------------+ 
                          ^
                          |
                        Read
                          |
                   +----------------------------+
   Utility         |      AdcReadClientC        |
  component:       |  (using AdcReadArbiterC)   | location: tinyos-2.x/tos/lib/adc
                   +----------------------------+ 
                      ^            ^
                      |            |
                    Read[]       Resource[]
                      |            |
                   +---------------------+
    HAL2:          |       AdcC          | location: tinyos-2.x/tos/chips/msp430
                   +---------------------+
                      ^            ^
                      |            |
                   Msp430Adc12-  Resource[]
                  SingleChannel    |
                      |            |
                   +-----------------------+
    HAL1:          |    Msp430Adc12C       |location: tinyos-2.x/tos/chips/msp430
                   +-----------------------+
                            ^
                            |
                      Msp430Adc12Hpl
                            |
                   +---------------------+
    HPL:           |   Msp430Adc12HplC   | location: tinyos-2.x/tos/chips/msp430
                   +---------------------+


Sensor Configuration
--------------------------------------------------------------------

The main task of a sensor wrapper component is to provide to the HAL2 the
sensor's ADC configuration settings.  This is done in the implementation
section of the sensor wrapper component by wiring the AdcC configuration
interface to the respective configuration component. An example is shown
below.::


  configuration PhotoSensorC
  {
    provides interface Read<uint16_t> as Read;
  }
  implementation
  {
    enum {
      CLIENT_ID = unique("ADC_CLIENT")
    };
  
    components AdcC, PhotoSensorSettingsM, 
               new AdcReadClientC(CLIENT_ID, uint16_t) as ReadClient;
  
    Read = ReadClient;
    AdcC.Msp430Adc12Config[CLIENT_ID] -> 
      PhotoSensorSettingsM.Msp430Adc12Config[PHOTO_SENSOR_DEFAULT];
  }

  module PhotoSensorSettingsM {
    provides interface Msp430Adc12Config[uint8_t type];  
  }
  implementation
  {
    async command msp430adc12_channel_config_t 
      Msp430Adc12Config.getChannelSettings[uint8_t type]()
    {
      msp430adc12_channel_config_t settings = {
                        INPUT_CHANNEL_A2, REFERENCE_VREFplus_AVss, REFVOLT_LEVEL_1_5,
                        SHT_SOURCE_ACLK, SHT_CLOCK_DIV_1, SAMPLE_HOLD_4_CYCLES,
                        SAMPCON_SOURCE_ACLK, SAMPCON_CLOCK_DIV_1 };
      switch (type)
      {
        case PHOTO_SENSOR_DEFAULT:
          break;
        case PHOTO_SENSOR_HIGH_FREQUENCY:
          settings.sampcon_ssel = SAMPCON_SOURCE_SMCLK;
          break;
      }
      return settings;
    }
  }

