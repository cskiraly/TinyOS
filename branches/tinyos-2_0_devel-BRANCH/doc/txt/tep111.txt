============================
message_t
============================

:TEP: 111
:Group: Core Working Group 
:Type: Documentary
:Status: Draft
:TinyOS-Version: 2.x
:Author: Philip Levis

:Draft-Created: 11-Jul-2005
:Draft-Version: $Revision: 1.1.2.2 $
:Draft-Modified: $Date: 2005-12-16 19:18:10 $
:Draft-Discuss: TinyOS Developer List <tinyos-devel at mail.millennium.berkeley.edu>

.. Note::

   This memo documents a part of TinyOS for the TinyOS Community, and
   requests discussion and suggestions for improvements.  Distribution
   of this memo is unlimited. This memo is in full compliance with
   TEP 1.

Abstract
====================================================================

This memo covers the TinyOS 2.x message buffer abstraction, ``message_t``.
It describes the message buffer design considerations, how and where 
``message_t`` is specified, and how data link layers should access it. 

1. Introduction
====================================================================

In TinyOS 1.x, a message buffer is a TOS_Msg. A buffer contains an
active message (AM) packet as well as packet metadata, such as timestamps,
acknowledgement bits, and signal strength if the packet was received.
TOS_Msg is a fixed size structure whose size is defined by the maximum
AM payload length (the default is 29 bytes). Fixed sized buffers allows
TinyOS 1.x to have zero-copy semantics: when a component receives a
buffer, rather than copy out the contents it can return a pointer
to a new buffer for the underlying layer to use for the next received 
packet.

One issue that arises is what defines the TOS_Msg structure, as different
link layers may require different layouts. For example, 802.15.4 radio 
hardware (such as the CC2420, used in the Telos and micaZ platforms) 
may require 802.15.4 headers, while a software stack built on top of
byte radios (such as the CC1000, used in the mica2 platform) can specify 
its own packet format. This means that TOS_Msg may be different on
different platforms.

The solution to this problem in TinyOS 1.x is for there to be a standard
definition of TOS_Msg, which a platform (e.g., the micaZ) can
redefine to match its radio. For example, a mica2 mote uses the standard 
definition, which is

|  ``typedef struct TOS_Msg {``
|    ``// The following fields are transmitted/received on the radio.``
|    ``uint16_t addr;``
|    ``uint8_t type;``
|    ``uint8_t group;``
|    ``uint8_t length;``
|    ``int8_t data[TOSH_DATA_LENGTH];``
|    ``uint16_t crc;``
|
|    ``// The following fields are not actually transmitted or received``
|    ``// on the radio! They are used for internal accounting only.``
|    ``// The reason they are in this structure is that the AM interface``
|    ``// requires them to be part of the TOS_Msg that is passed to``
|    ``// send/receive operations.``
|    
|    ``uint16_t strength;``
|    ``uint8_t ack;``
|    ``uint16_t time;``
|    ``uint8_t sendSecurityMode;``
|    ``uint8_t receiveSecurityMode;``
|  ``} TOS_Msg;``

while on a mote with a CC420 radio (e.g., micaZ), TOS_Msg is defined as:

|  ``typedef struct TOS_Msg {``
|    ``// The following fields are transmitted/received on the radio.``
|    ``uint8_t length;``
|    ``uint8_t fcfhi;``
|    ``uint8_t fcflo;``
|    ``uint8_t dsn;``
|    ``uint16_t destpan;``
|    ``uint16_t addr;``
|    ``uint8_t type;``
|    ``uint8_t group;``
|    ``int8_t data[TOSH_DATA_LENGTH];``
|    
|    ``// The following fields are not actually transmitted or received``
|    ``// on the radio! They are used for internal accounting only.``
|    ``// The reason they are in this structure is that the AM interface``
|    ``// requires them to be part of the TOS_Msg that is passed to``
|    ``// send/receive operations.``
|    
|    ``uint8_t strength;``
|    ``uint8_t lqi;``
|    ``bool crc;``
|    ``uint8_t ack;``
|    ``uint16_t time;``
| ``} TOS_Msg;``

There are two basic problems with this approach. First, exposing all of
the link layer fields leads components to directly access the packet
structure. This introduces dependencies between higher level components
and the structure layout. For example, many network services built on
top of data link layers care whether sent packets are acknowledged. They
therefore check the ``ack`` field of TOS_Msg. If a link layer does not 
provide acknowledgements, it must still include the ``ack`` field
and always set it to 0, wasting a byte of RAM per buffer.

Second, this model does not easily support multiple data link layers.
Radio chip implementations assume that the fields they require are 
defined in the structure and directly access them. If a platform
has two different link layers (e.g., a CC1000 *and* a CC2420 radio),
then a TOS_Msg needs to allocate the right amount of space for both
of their headers while allowing implementations to directly access
header fields. This is very difficult to do in C.

The ``data`` payload is especially problematic. Many
components refer to this field, so it must be at a fixed offset.
Depending on the underlying link layer, the header fields 
preceding it might have different lengths, and packet-level radios
often require packets to be contiguous memory regions. Overall, these 
complexities make specifying the format of TOS_Msg very difficult.

2. message_t
====================================================================

In TinyOS 2.x, the standard message buffer is ``message_t``. The
message_t structure is defined in ``tos/types/TOSMsg.h``:

|  ``typedef nx_struct message_t {``
|    ``TOSRadioHeader header;``
|    ``nx_uint8_t data[TOSH_DATA_LENGTH];``
|    ``TOSRadioFooter footer;``
|    ``TOSRadioMetadata metadata;``
|  ``} message_t;``

This format keeps data at a fixed offset, which is important when
passing a message buffer between two different link layers. If
the data payload is at different offsets for different link layers,
then passing a packet between two link layers requires a ``memmove(3)``
operation (essentially, a copy).

The header, footer, and metadata fields are all opaque. Higher
level components access their fields through interfaces. Section
3 discusses this in greater depth.

Every link layer defines its header, footer, and metadata
structures. These structures MUST be network structs, and all of their
fields MUST be network types, in order to ensure cross-platform
compatibility.  For example, the CC1000 radio implementation defines
its structures in ``CC1000Msg.h``:

|  ``typedef nx_struct CC1KHeader {``
|    ``nx_am_addr_t addr;``
|    ``nx_uint8_t length;``
|    ``nx_am_group_t group;``
|    ``nx_am_id_t type;``
|  ``} CC1KHeader;``
| 
|  ``typedef nx_struct CC1KFooter {``
|    ``nxle_uint16_t crc;``
|  ``} CC1KFooter;``
| 
|  ``typedef nx_struct CC1KMetadata {``
|    ``nx_uint16_t strength;``
|    ``nx_uint8_t ack;``
|    ``nx_uint16_t time;``
|    ``nx_uint8_t sendSecurityMode;``
|    ``nx_uint8_t receiveSecurityMode;``
|  ``} CC1KMetadata;``

Each link layer defines its structres, but a **platform** is responsible 
for defining ``TOSRadioHeader``, ``TOSRadioFooter``, and ``TOSRadioMetadata``. 
This is because a platform may have multiple link layers, and so only
it can resolve which structures are needed. These definitions MUST be
in a file in a platform directory named ``RadioTOSMsg.h``.
The mica2 platform is a simple example, as it has only a CC1000 radio.
Its RadioTOSMsg.h looks like this:

| ``typedef CC1KHeader TOSRadioHeader;``
| ``typedef CC1KFooter TOSRadioFooter;``
| ``typedef CC1KMetadata TOSRadioMetadata;``

For a more complex example, consider a fictional platform named 'megamica' 
that has both a CC1000 and a CC2420 radio. Its RadioTOSMsg.h looks like this:

|  ``typedef union MegaMicaHeader {``
|    ``CC1KHeader cc1k;``
|    ``CC2420Header cc2420;``
|  ``} MegaMicaHeader;``
|
|  ``typedef union MegaMicaFooter {``
|    ``CC1KFooter cc1k;``
|    ``CC2420Footer cc2420;``
|  ``} MegaMicaFooter;``
|
|  ``typedef union MegaMicaMetadata {``
|    ``CC1KMetadata cc1k;``
|    ``CC2420Metadata cc2420;``
|  ``} MegaMicaMetadata;``
| 
| ``typedef MegaMicaHeader TOSRadioHeader;``
| ``typedef MegaMicaFooter TOSRadioFooter;``
| ``typedef MegaMicaMetadata TOSRadioMetadata;``

If a platform has more than one link layer, it SHOULD define each of the
message_t fields to be a union of the underlying link layer structures.
This ensures that enough space is allocated for all underlying link layers.

3. Message_t fields
====================================================================

A TinyOS component MUST NOT access any message_t fields directly besides
its top-level structures: 

  o TOSRadioHeader
  o data
  o TOSRadioFooter
  o TOSRadioMetadata

That is, a TinyOS component MUST NOT access any sub-fields of these
structures. Components above the link layer MUST access packet fields
through a nesC interface. For example, active messages have an interface
named ``AMPacket`` which provides access commands to AM fields. In
TinyOS 1.x, a component would directly access ``TOS_Msg.addr``;
in TinyOS 2.x, a component calls ``AMPacket.getAddress(msg)``.

3.1 TOSRadioHeader
----------------------------------------------------------------

Link layer components MAY handle packet fields differently than other 
components, as they are aware of the actual packet format. They can
therefore implement the interfaces that provide access to the fields
for other components.

Link layer components MUST NOT directly access sub-fields
of message_t. There are two reasons for this. First, whether 
each type is their link type or a union of link types is unknown, 
as it can change depending on the platform. 
Each of these cases has different C syntax, and in the union case the
name of the field is unknown. 

Second, although the structures ensure that enough space is allocated, 
C's placement of the structures is not necessarily correct.
Defining a message_t header as a union of the underlying link layer headers
means that, in terms of C structures, a packet may not be contiguous. For
example, consider this case:

|  ``typedef struct HeaderA {``
|    ``uint8_t a;``
|  ``}``
|  ``typedef struct HeaderB {``
|    ``uint16_t b;``
|  ``}``
|  ``typedef union MyHeader {``
|    ``HeaderA A;``
|    ``HeaderB B;``
|  ``}``
|  ``typedef MyHeader TOSRadioHeader;``

Given nesC nx_struct layout, when TOSRadioHeader is specified as a union
of HeaderA and HeaderB, there will be a padding byte after ``HeaderA.a``.
However, some radios require that packets passed to them are contiguous.

The packet for a link layer does not necessarily start at the beginning
of the message_t. Instead, is starts at a negative offset from the
data field.  When a link layer component needs to read or write protocol 
header fields, it MUST compute the location of the header as a negative 
offset from the data field. The padding bytes that C introduces for
the different sized headers are at the beginning of message_t, not
between the header and payload. For example, let us suppose that HeaderA
has an interface ``APacket``, which provides a command ``a`` that 
returns the field ``a`` of HeaderA. Its code looks like this:

|  ``command uint8_t APacket.a(message_t* msg) {``
|    ``HeaderA* hdr = (HeaderA*)(msg->data - sizeof(HeaderA));``
|    ``return hdr->a;``
|  ``}``

We can trust the C compiler to optimize the call into a static offset
memory load.

The following code is incorrect, as it directly casts the header field.
It is an example of what components MUST NOT do:

|  ``command uint8_t APacket.a(message_t* msg) {``
|    ``HeaderA* hdr = (HeaderA*)(msg->header);``
|    ``return hdr->a;``
|  ``}``

The following example is also incorrect, as it directly accesses the
header structure. It is an example of what components MUST NOT do.

|  ``command uint8_t APacket.a(message_t* msg) {``
|    ``return msg->header.A.a;``
|  ``}``


3.2 TOSRadioFooter
----------------------------------------------------------------

The TOSRadioFooter field ensures that message_t has enough space
to store the footers for all underlying link layers when there
are MTU-sized packets. Like headers, footers are not necessarily
stored where the C structs indicate they are: instead, their
placement is implementation dependent. For example, a link
layer can store a full packet as a contiguous area of memory. In
this case, a short packet will store the footer within the ``data``
field of the structure.

The placement of the packet footer is implementation dependent.

The footer starts at the start of the footer field, and metadata begins
at the start of the metadata field. However, data link components MUST 
NOT directly access these fields, as their structure is platform
dependent. A component MUST cast these fields to link specific structures. 

The basic issue driving these design considerations is that 
the C naming layout of message_t fields is platform specific. As a
data link implementation may be used on many platforms, an implementation
cannot depend on a particular C naming. An implementation can depend on 
there being enough space for its header and footer in message_t.

Following this approach means that the packet header and data payload
are contiguous in memory, which allows other communication abstractions
(such as a UART, see TEP 113[_tep113]) to easily encapsulate a packet.

4. Author's Address
====================================================================

| Philip Levis
| 358 Gates Hall
| Computer Science Laboratory
| Stanford University
| Stanford, CA 94305
|
| phone - +1 650 725 9046
| email - pal@cs.stanford.edu

5. Citations
====================================================================

.. [tep113] TEP 113: Serial Communication.
