<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.7: http://docutils.sourceforge.net/" />
<title>Analog-to-Digital Converters (ADCs)</title>
<meta name="author" content="Jan-Hinrich Hauer" />
<meta name="author" content="Philip Levis" />
<meta name="author" content="Vlado Handziski" />
<meta name="author" content="David Gay" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="analog-to-digital-converters-adcs">
<h1 class="title">Analog-to-Digital Converters (ADCs)</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">101</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Core Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Documentary</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.x</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Jan-Hinrich Hauer</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>Philip Levis</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>Vlado Handziski</td></tr>
<tr><th class="docinfo-name">Author:</th>
<td>David Gay</td></tr>
<tr class="field"><th class="docinfo-name">Draft-Created:</th><td class="field-body">20-Dec-2004</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Version:</th><td class="field-body">1.1.2.3</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Modified:</th><td class="field-body">2006-01-12</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Discuss:</th><td class="field-body">TinyOS Developer List &lt;tinyos-devel at mail.millennium.berkeley.edu&gt;</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This memo documents a part of TinyOS for the TinyOS Community, and
requests discussion and suggestions for improvements.  Distribution
of this memo is unlimited. This memo is in full compliance with
TEP 1.</p>
</div>
<div class="section" id="abstract">
<h1><a name="abstract">Abstract</a></h1>
<p>This TEP proposes a hardware abstraction for TinyOS 2.x analog-to-digital
converters (ADCs). It focuses on aligning the ADC abstraction with the
three-layer Hardware Abstraction Architecture (HAA) described in TEP 2, but
addresses only the HPL and HAL, because the highest level abstraction of an
ADC is platform-dependent.</p>
</div>
<div class="section" id="introduction">
<h1><a name="introduction">1. Introduction</a></h1>
<p>Analog-to-digital converters (ADCs) are devices that convert analog input
signals to discrete digital output signals, typically voltage to a digital
number.  The interested reader can refer to Appendix A for a brief overview of
the ADC hardware on some current TinyOS platforms.  In earlier versions of
TinyOS, the distinction between a sensor and an ADC were blurred: this led
components that had nothing to do with an ADC to still resemble one
programatically, even though the semantics and forms of operation were
completely different.  To compensate for the difference non-ADC sensors
introduced additional interfaces, such as ADCError, that were tightly bound to
sensor acquisition but separate in wiring. The separation between the ADC and
ADCError interface is bug prone and problematic, as is the equation of a
sensor and an ADC. TinyOS 2.x separates the structure and interfaces of an ADC
from those of sensors (which may be on top of an ADC, but this fact is hidden
from higher level components). This TEP presents how TinyOS 2.x decomposes and
structures ADC software. TEP 109 (Sensor Boards) shows how a platform can
present actual named sensors [_tep109].</p>
<p>As can be seen in Appendix A the ADC hardware used on TinyOS platforms differ
in many respects, which makes it difficult to find a chip independent
representation for an ADC. Even if there were such a representation, the
configuration details of an ADC would still depend on the actual device
producing the input signal (sensor).  Neither a platform independent
application nor the ADC hardware stack itself has access to this information,
as it can only be determined on a platform or sensorboard level. For example,
determining which ADC port a sensor is attached to and how a conversion result
is to be interpreted is a platform-specific determination.</p>
<p>In spite of their hardware differences, one aspect represents a common
denominator of all ADCs: they produce conversion results. In order to
facilitate sensor software development this capability can be made available
via chip-independent interfaces for every ADC. However, conversion results
depend on and have to be interpreted with respect to the platform-specific
configuration settings (the ADC channel, the applied reference voltage, etc.).
Therefore the highest level of ADC abstraction consists of
platform-independent interfaces for ADC data collection and chip-specific
interfaces for ADC hardware configuration.  The top ADC layer thus remains
platform-dependent and consequently the ADC abstraction does not include an
HIL, but ends with the HAL. Following the principles of the HAA[_tep2] the HAL
of an ADC should also expose the chip-specific capabilities for ADC data
collection. For example, the ADC12 on the msp430 supports a complex repeated
conversion mode for a set of different input channels, which is too specific
to be represented by a platform-independent data collection interface.
Therefore the HAL of an ADC abstraction is broken into two sublayers: The
bottom HAL layer, called HAL1, exposes the full capabilities of the respective
ADC in a chip-specific way. It realizes the standard HAL in the HAA[_tep2] and
the HPL lies below it.  On top of the HAL1 sits the HAL2 which maps the
interfaces it uses from HAL1 to a set of platform-independent interfaces for
data collection and chip-specific configuration interfaces.</p>
<p>The rest of this TEP specifies:</p>
<ul class="simple">
<li>the set of platform-independent interfaces for the collection of ADC
conversion results (<a class="reference" href="#interfaces">2. Interfaces</a>)</li>
<li>guidelines on how an ADC's HAL SHOULD should be split into HAL1 and HAL2 and
how the HAL1 SHOULD expose chip-specific interfaces (<a class="reference" href="#hal1-guidelines">3. HAL1 guidelines</a>)</li>
<li>what components an ADC's HAL2 MUST implement (<a class="reference" href="#hal2-requirements">4. HAL2 requirements</a>)</li>
<li>a set of utility components which simplify usage of the HAL2 components
(<a class="reference" href="#utility-components">5. Utility components</a>)</li>
</ul>
<p>This TEP ends with appendices documenting, as an example, the ADC
implementation for the TI MSP430.</p>
</div>
<div class="section" id="interfaces">
<h1><a name="interfaces">2. Interfaces</a></h1>
<p>This TEP proposes to adopt the following three generic, source-independent
data collection interfaces from the SID TEP [_tep114] for the collection of
ADC conversion results:</p>
<pre class="literal-block">
interface Read&lt; size_type &gt;
interface ReadNow&lt; size_type &gt;
interface ReadStream&lt; size_type &gt;
</pre>
<p>Every data collection interface is associated with certain chip-specific
configuration data (e.g. input channel, sample-hold-time, etc.).  How this
association can be realized is explained in Section <a class="reference" href="#hal2-requirements">4.  HAL2 requirements</a>.
As the resolution of conversion results is chip-specific, the 'size_type'
parameter reflects an upper bound for the chip-specific resolution of the
conversion results - the actual resolution may be smaller, depending on the
ADC and/or data source (e.g.  uint16_t for a 12-bit ADC). The above interfaces
are specified in the SID TEP [_tep114], in the following their usage is
explained with respect to ADCs.</p>
<div class="section" id="read">
<h2><a name="read">Read</a></h2>
<p>The Read interface can be used to sample an ADC channel and return a single
conversion result. It provides no guarantees about when exactly the sampling
occurs (the request may be buffered).</p>
</div>
<div class="section" id="readnow">
<h2><a name="readnow">ReadNow</a></h2>
<p>The ReadNow interface provides more precise control over the time of the
sampling: If ReadNow.read() succeeds, the ADC starts to sample the channel
immediately (the request is not buffered).</p>
</div>
<div class="section" id="readstream">
<h2><a name="readstream">ReadStream</a></h2>
<p>The ReadStream interface can be used to sample an ADC channel multiple times
with a specified sampling period. It provides no guarantees about when exactly
the first sampling occurs, but all subsequent sampling occurs with the
specified sampling period.</p>
</div>
</div>
<div class="section" id="hal1-guidelines">
<h1><a name="hal1-guidelines">3. HAL1 guidelines</a></h1>
<p>As explained in <a class="reference" href="#introduction">1. Introduction</a> the HAL of an ADC abstraction consists of
two sublayers, HAL1 and HAL2. In the ADC component stack the HAL1 resides
below HAL2 and above the HPL. It exposes the full capabilities of the ADC in a
chip-specific way and has the same function as the 'traditional' HAL in the
HAA[_tep2] and therefore only chip- and platform-dependent clients MAY wire to
the HAL1. Although the HAL1 is chip-specific both in terms of implementation
and representation, its design SHOULD follow the guidelines described below to
facilitate the mapping to platform-independent interfaces on the level of
HAL2. Appendix B shows the HAL1 specification for the TI MSP430 MCU.</p>
<div class="section" id="resource-reservation">
<h2><a name="resource-reservation">Resource reservation</a></h2>
<p>As the ADC hardware is a shared resource that is multiplexed between several
clients, it requires access arbitration. Therefore the HAL1 configuration
component SHOULD provide the 'Init' and a parameterized 'Resource' interface,
instantiate a generic arbiter component and wire both interfaces to the
arbiter as described in TEP 108 [_tep108]. To provide a uniform arbitration
service for all platforms on the level of HAL2 (see <a class="reference" href="#hal2-requirements">4. HAL2 requirements</a>),
all ADCs should be arbitrated in round robin fashion, i.e. the HAL1 SHOULD
instantiate the standard round robin arbiter.</p>
</div>
<div class="section" id="configuration-and-sampling">
<h2><a name="configuration-and-sampling">Configuration and sampling</a></h2>
<p>As the ADC hardware is a shared resource the HAL1 SHOULD support hardware
configuration and sampling on a per-client basis (although per-port
configuration is possible, it is not recommended, because it forces all
clients to use the same settings for a given port). Therefore an HAL1 SHOULD
provide &quot;sampling interfaces&quot; parameterized by a client identifier. An HAL1
client can use its instance of the sampling interface to configure the ADC
hardware, start the sampling process and get conversion results. It wires to a
sampling interface using a unique client identifier. All commands and events
in the sampling interface SHOULD be 'async' to reflect the potential timing
requirements of clients. An HAL1 MAY provide multiple different parameterized
sampling interfaces, depending on the hardware capabilities.  This allows to
differentiate/group ADC functionality, for example single vs.  repeated
sampling, single channel vs. multiple channels or low-frequency vs.
high-frequency sampling.  Every sampling interface SHOULD lead the client to
individually configure the ADC hardware, for example by including the
configuration data as parameters in the sampling commands.  However, if
configuration data is passed as a pointer, the HAL1 component MUST NOT
reference it after the return of the respective command. Appendix B shows the
HAL1 interfaces for the TI MSP430 MCU.</p>
</div>
<div class="section" id="hal1-virtualization">
<h2><a name="hal1-virtualization">HAL1 virtualization</a></h2>
<p>In order to hide wiring complexities and/or export only a subset of all ADC
functions generic ADC wrapper components MAY be provided on the level of HAL1
to be instantiated by chip- and platform-dependent clients.</p>
</div>
</div>
<div class="section" id="hal2-requirements">
<h1><a name="hal2-requirements">4. HAL2 requirements</a></h1>
<p>For every ADC there MUST be a module that <em>provides</em> the following
interfaces:</p>
<pre class="literal-block">
#define ADCC_SERVICE ...
module AdcC {
  provides {
    interface Init;
    interface Read&lt; size_type &gt; as Read[uint8_t client];
    interface ReadNow&lt; size_type &gt; as ReadNow[uint8_t client];
    interface ReadStream&lt; size_type &gt; as ReadStream[uint8_t client];
  }
  uses {
    // chip-specific sampling interface (parameterized by client)
    // chip-specific configuration interface (parameterized by client)
    // Resource interface (parameterized by client)
  }
}
</pre>
<p>The name of the module can, but it doesn't have to be AdcC (but for simplicity
in the following the HAL2 implementation will be referred to as &quot;AdcC&quot;). The
task of the AdcC is twofold: it translates the chip-specific sampling
interface(s) provided by the HAL1 to platform independent interfaces for
data-collection and it abstracts from the 'Resource' interface.</p>
<p>However, the first task cannot entirely be solved in a chip-independent way,
because it involves chip-specific configuration data: For example, in order to
translate a 'Read.read()' request to a HAL1 request, the AdcC needs to know
the respective ADC port, reference voltage, sample-hold-time, etc. This
information is chip- and platform-specific and can only be specified by the
HAL2 client. Therefore in its specification the AdcC SHOULD use a
chip-specific configuration interface and the client SHOULD wire it to a
component that holds its configuration data (such a configuration interface
will typically include only a single command that returns the client's ADC
hardware settings). In order to let the AdcC establish a mapping between the
configuration and the data collection interface, the client MUST use the same
unique client identifier for both interfaces using unique(ADCC_SERVICE).</p>
<p>Each client of the AdcC MUST also wire the AdcC to a chip-specific sampling
and to the 'Resource' interface provided by the HAL1. In order to let the AdcC
establish a correct mapping the client MUST instantiate all interfaces using
the same unique(ADCC_SERVICE) identifier and it MUST ensure that the HAL1 is
properly initialized. To eliminate wiring errors, a client is recommended to
not wire to the AdcC directly, but use one of the wrappers described in
Section '5.  Utility components'_.</p>
<p>From the perspective of the AdcC the typical sequence of events is as follows:
After a client has requested data the AdcC will request access to the HAL1 via
the 'Resource' interface.  When it is signalled the 'granted' event, the AdcC
will 'pull' the client's ADC settings and translate the read() call to a
chip-specific HAL1 sampling command. Once it is signalled the conversion
result the AdcC releases the ADC via the 'Resource' interface and forwards the
conversion result to the client. For all involved interfaces the AdcC uses the
same client identifier.</p>
<p>The reason why there is no HAL2 configuration for an ADC, which establishes
the wiring to HAL1 automatically, i.e. the reason why an HAL2 client needs to
wire the AdcC to the HAL1 is as follows: The HAL1 can be accessed by both,
chip-specific applications and the HAL2. If the HAL2 wired to the
parameterized Resource and sampling interfaces provided by HAL1 it would
exclude chip-specific applications that wanted to wire to HAL1 directly (the
HAL2 would be signalled thier events).</p>
<p>Note that, although the <em>provided</em> interfaces are platform independent, the
fact that the AdcC <em>uses</em> chip-dependent interfaces and the fact that the
provided interfaces for data-collection are parameterized by a client
identifier that maps to the respective ADC configuration data makes the HAL2
representation chip dependent. Therefore the ADC abstraction does not include
an HIL. However, separating the ADC configuration data from the data
collection interfaces facilitates the design of platform independent
applications.</p>
<p>Appendix B shows the AdcC specification for the TI MSP430 MCU.</p>
</div>
<div class="section" id="utility-components">
<h1><a name="utility-components">5. Utility components</a></h1>
<p>The following utility components SHOULD be built on top of the HAL2 to
facilitate access to the ADC system:</p>
<ul class="simple">
<li>AdcReadClient</li>
<li>AdcReadNowClient</li>
<li>AdcReadStreamClient</li>
</ul>
<p>The purpose of these HAL2 wrappers is to hide the wiring complexities
mentioned in Section '4. HAL2 requirements'_. Appendix C shows the
AdcReadClient for the TI MSP430 MCU and describes how a component can provide
multiple different configurations for the same device (e.g. for high- or
low-frequency sampling).</p>
<div class="section" id="adcreadclient">
<h2><a name="adcreadclient">AdcReadClient</a></h2>
<pre class="literal-block">
generic configuration AdcReadClient() {
  provides {
    interface Init;
    interface Read&lt; size_type &gt; as Read;
  }
  uses {
    // chip-dependent configuration interface
  }
}
</pre>
</div>
<div class="section" id="adcreadnowclient">
<h2><a name="adcreadnowclient">AdcReadNowClient</a></h2>
<pre class="literal-block">
generic configuration AdcReadNowClient() {
  provides {
    interface Init;
    interface ReadNow&lt; size_type &gt; as ReadNow;
  }
  uses {
     // chip-dependent configuration interface
   }
}
</pre>
</div>
<div class="section" id="adcreadstreamclient">
<h2><a name="adcreadstreamclient">AdcReadStreamClient</a></h2>
<pre class="literal-block">
generic configuration AdcReadStreamClient() {
  provides {
    interface Init;
    interface ReadStream&lt; size_type &gt; as ReadStream;
  }
  uses {
     // chip-dependent configuration interface
   }
}
</pre>
</div>
</div>
<div class="section" id="appendix-a-hardware-differences-between-platforms">
<h1><a name="appendix-a-hardware-differences-between-platforms">Appendix A: Hardware differences between platforms</a></h1>
<p>The following table compares the characteristics of two microcontrollers
commonly used in TinyOS platforms:</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="34%" />
<col width="32%" />
</colgroup>
<thead valign="bottom">
<tr><th>&nbsp;</th>
<th>Atmel Atmega 128</th>
<th>TI MSP430 ADC12</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>Resolution</td>
<td>10-bit</td>
<td>12-bit</td>
</tr>
<tr><td>channels</td>
<td><ul class="first last simple">
<li>8 multiplexed
external channels</li>
<li>16 differential
voltage input
combinations</li>
<li>2 differential
inputs with gain
amplification</li>
</ul>
</td>
<td><ul class="first last simple">
<li>8 individually
configurable
external channels</li>
<li>internal channels
(AVcc, temperature,
reference voltages)</li>
</ul>
</td>
</tr>
<tr><td>internal reference
voltage</td>
<td>2.56V</td>
<td>1.5V or 2.5V</td>
</tr>
<tr><td>conversion reference</td>
<td><ul class="first last simple">
<li>positive terminal:
AVcc or 2.56V  or
AREF (external)</li>
<li>negative terminal:
GND</li>
</ul>
</td>
<td><blockquote class="first">
individually
selectable per
channel:</blockquote>
<ul class="last simple">
<li>AVcc and AVss</li>
<li>Vref+ and AVss</li>
<li>Veref+ and AVss</li>
<li>AVcc and (Vref- or
Veref-)</li>
<li>AVref+ and (Vref-
or Veref-)</li>
<li>Veref+ and (Vref-
or Veref-)</li>
</ul>
</td>
</tr>
<tr><td>conversion modes</td>
<td><ul class="first last simple">
<li>single channel
conversion mode</li>
<li>free running mode
(channels and
reference voltages
can be switched
between samples)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>single conversion
mode</li>
<li>repeat single
conversion mode</li>
<li>sequence mode
(sequence &lt;= 16
channels)</li>
<li>repeat sequence
mode</li>
</ul>
</td>
</tr>
<tr><td>conversion clock
source</td>
<td>clkADC with prescaler</td>
<td>ACLK, MCLK, SMCLK or
ADC-oscillator (5MHz)
with prescaler
respectively</td>
</tr>
<tr><td>sample-hold-time</td>
<td>1.5 clock cycles
(fixed)</td>
<td>selectable values
from 4 to 1024 clock
cycles</td>
</tr>
<tr><td>conversion triggering</td>
<td>by software</td>
<td>by software or timers</td>
</tr>
<tr><td>conversion during
sleep mode possible</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr><td>interrupts</td>
<td>after each conversion</td>
<td>after single or
sequence conversion</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="appendix-b-an-adc-msp430-adc12">
<h1><a name="appendix-b-an-adc-msp430-adc12">Appendix B: an ADC: MSP430 ADC12</a></h1>
<p>The following shows the HAL1 representation for the ADC12 of the TI MSP430
MCU. It reflects the MSP430 ADC12 &quot;conversion modes&quot; as it lets a client
sample an ADC channel once (&quot;Single-channel-single-conversion&quot;) or repeatedly
(&quot;Repeat-single-channel&quot;), multiple times (&quot;Sequence-of-channels&quot;) or multiple
times repeatedly (&quot;Repeat-sequence-of-channels&quot;). In contrast to the single
channel conversion modes the sequence conversion modes create a single
interrupt after multiple samples and thus enable high-frequency sampling (a
sequence conversion mode for multiple different channels is not yet
implemented).:</p>
<pre class="literal-block">
configuration Msp430Adc12C
{
  provides interface Init;
  provides interface StdControl;
  provides interface Resource[uint8_t id];
  provides interface Msp430Adc12SingleChannel as SingleChannel[uint8_t id];
}

interface Msp430Adc12SingleChannel 
{   
  async command msp430adc12_result_t getSingleData(
      const msp430adc12_channel_config_t *config);

  async command msp430adc12_result_t getSingleDataRepeat( 
      const msp430adc12_channel_config_t *config, 
      uint16_t jiffies);

  async command msp430adc12_result_t getMultipleData(
      const msp430adc12_channel_config_t *config,
      uint16_t *buf, uint16_t length, uint16_t jiffies);

  async command msp430adc12_result_t getMultipleDataRepeat(
      const msp430adc12_channel_config_t *config,
      uint16_t *buf, uint8_t length, uint16_t jiffies);

  async command error_t stop();

  async event error_t singleDataReady(uint16_t data);

  async event uint16_t* multipleDataReady(uint16_t *buf, uint16_t length);
}
</pre>
<p>The Msp430Adc12C SHOULD be accessed via the following wrapper.:</p>
<pre class="literal-block">
generic configuration Msp430Adc12ClientC()
{
  provides interface Init;
  provides interface Resource;
  provides interface Msp430Adc12SingleChannel;
} implementation {
  components Msp430Adc12C;
   
  enum {
    ID = unique(MSP430ADC12_RESOURCE),
  };
  Init = Msp430Adc12C.Init;
  Resource = Msp430Adc12C.Resource[ID];
  Msp430Adc12SingleChannel = Msp430Adc12C.SingleChannel[ID];
}
</pre>
<p>The HAL2 is represented by the following AdcC module. For implementation
details it distinguishes between clients that use the 'Read' or 'ReadNow' and
clients that use the 'ReadStream' interface.:</p>
<pre class="literal-block">
module AdcC {
  provides {
    interface Init;
    interface Read&lt;uint16_t&gt; as Read[uint8_t client];
    interface ReadNow&lt;uint16_t&gt; as ReadNow[uint8_t client];
    interface ReadStream&lt;uint16_t&gt; as ReadStream[uint8_t rsClient];
  }
  uses {
    // for Read and ReadNow:
    interface Resource as Resource[uint8_t client];
    interface Msp430Adc12Config as Config[uint8_t client];
    interface Msp430Adc12SingleChannel as SingleChannel[uint8_t client];
    // for ReadStream:
    interface Resource as ResourceReadStream[uint8_t rsClient];
    interface Msp430Adc12Config as ConfigReadStream[uint8_t rsClient];
    interface Msp430Adc12SingleChannel as SingleChannelReadStream[uint8_t rsClient];
  }
}
</pre>
</div>
<div class="section" id="appendix-c-an-msp430-adc12-utility-component-and-sensor-wrapper">
<h1><a name="appendix-c-an-msp430-adc12-utility-component-and-sensor-wrapper">Appendix C: an MSP430 ADC12 utility component and sensor wrapper</a></h1>
<p>The following two sections show a utility component and a sensor wrapper for
the MSP430 ADC12.</p>
<div class="section" id="utility-component">
<h2><a name="utility-component">Utility Component</a></h2>
<p>An HAL2 wrapper hides the wiring complexities from the client. For the MSP430
ADC12 the AdcReadClientC is implemented as follows.:</p>
<pre class="literal-block">
#include &lt;Msp430Adc12.h&gt;
generic configuration AdcReadClientC() {
  provides {
    interface Init;
    interface Read&lt;uint16_t&gt; as Read;
  }
  uses interface Msp430Adc12Config;
} implementation {
  components new Msp430Adc12ClientC() as Msp430AdcClient, AdcC;

  enum {
    CLIENT = unique(ADCC_SERVICE),
  };

  Init = AdcC;
  Init = Msp430AdcClient;
  Read = AdcC.Read[CLIENT];
  Msp430Adc12Config = AdcC.Config[CLIENT];
  AdcC.SingleChannel[CLIENT] -&gt; Msp430AdcClient.Msp430Adc12SingleChannel;
  AdcC.Resource[CLIENT] -&gt;  Msp430AdcClient.Resource;
}
</pre>
</div>
<div class="section" id="sensor-wrapper">
<h2><a name="sensor-wrapper">Sensor Wrapper</a></h2>
<p>The main task of a sensor wrapper component lies in providing to the HAL2 the
respective ADC configuration data. This is done by wiring the HAL2
(represented by a HAL2 wrapper) to a component that holds this data. How the
latter may store multiple different settings and how the sensor wrapper may
chose between them by wiring is shown below for the 'eyesIFX' platform.:</p>
<pre class="literal-block">
generic configuration PhotoSensorC()
{
  provides {
    interface Init;
    interface Read&lt;uint16_t&gt; as Read;
    interface ReadNow&lt;uint16_t&gt; as ReadNow;
  }
}
implementation
{
  components SensorSettingsC as Settings;
             
  components new AdcReadClientC() as AdcReadClient;
  Init = AdcReadClient;
  Read = AdcReadClient;
  AdcReadClient.Msp430Adc12Config -&gt; Settings.Msp430Adc12Config[PHOTO_SENSOR_DEFAULT];
  
  components new AdcReadNowClientC() as AdcReadNowClient;
  Init = AdcReadNowClient;
  ReadNow = AdcReadNowClient;
  AdcReadNowClient.Msp430Adc12Config -&gt; Settings.Msp430Adc12Config[PHOTO_SENSOR_VCC];
}

module SensorSettingsC {
  provides interface Msp430Adc12Config[uint8_t type];  
}
implementation
{
  async command msp430adc12_channel_config_t Msp430Adc12Config.getChannelSettings[uint8_t type]()
  {
    msp430adc12_channel_config_t defaultSettings = {INPUT_CHANNEL_NONE,0,0,0,0,0,0,0};
    switch (type)
    {
      case PHOTO_SENSOR_DEFAULT: 
        {
          msp430adc12_channel_config_t config = {
                      INPUT_CHANNEL_A2, REFERENCE_VREFplus_AVss, REFVOLT_LEVEL_1_5,
                      SHT_SOURCE_SMCLK, SHT_CLOCK_DIV_1, SAMPLE_HOLD_4_CYCLES,
                      SAMPCON_SOURCE_SMCLK, SAMPCON_CLOCK_DIV_1 };
          return config;
        }
      case PHOTO_SENSOR_VCC:
        {
          msp430adc12_channel_config_t config = {
                      INPUT_CHANNEL_A2, REFERENCE_AVcc_AVss, REFVOLT_LEVEL_NONE,
                      SHT_SOURCE_SMCLK, SHT_CLOCK_DIV_1, SAMPLE_HOLD_4_CYCLES,
                      SAMPCON_SOURCE_SMCLK, SAMPCON_CLOCK_DIV_1 };
          return config;
        }         
      // ...
    }
  // ..
  }
</pre>
</div>
</div>
</div>
</body>
</html>
