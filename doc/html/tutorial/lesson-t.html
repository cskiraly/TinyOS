<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <title>Lesson T: Simulation with TOSSIM</title>
  <link href="../../stylesheets/tutorial.css" rel="stylesheet" type="text/css">
</head>
<body>

$Id: lesson-t.html,v 1.1.2.2 2006-02-14 02:51:21 scipio Exp $

<div class="title">Lesson T: Simulation with TOSSIM</div>
<div class="subtitle">Last Modified: Feb 9, 2006</div>

      <p>This lesson introduces the TOSSIM simulator. You will become
        familiar with how to compile TOSSIM and use some of its
        functionality. You will learn how to:</p>

<p>

<ul>

<li>Compile TOSSIM.

<li>Configure a simulation in Python and C++.

<li>Inject packets.

<li>Inspect variables.

</ul>


<h1>Introduction</h1>

        TOSSIM simulates entire TinyOS applications. It works by
        replacing components with simulation implementations. The
        level at which components are replaced is very flexible: for
        example, there is a simulation implementation of millisecond
        timers that replaces HilTimerMilliC, while there is also an
        implementation for atmega128 platforms that replaces the HPL
        components of the hardware clocks. The former is general and
        can be used for any platform, but lacks the fidelity of
        capturing an actual chips behavior, as the latter
        does. Similarly, TOSSIM can replace a packet-level
        communication component for packet-level simulation, or
        replace a low-level radio chip component for a more precise
        simulation of the code execution.

        TOSSIM is a discrete event simulator. When it runs, it pulls
        events of the event queue (sorted by time) and executes them.
        Depending on the level of simulation, simulation events can
        represent hardware interrupts or high-level system events
        (such as packet reception). Additionally, tasks are simulation
        events, so that posting a task causes it to run a short time
        (e.g., a few microseconds) in the future.

        TOSSIM is a library: you must write a program that configures
        a simulation and runs it. TOSSIM supports two programming
        interfaces, Python and C++. Python allows you to interact with
        a running simulation dynamically, like a powerful
        debugger. However, as the interpretation can be a performance
        bottleneck when obtaining results, TOSSIM also has a C++
        interface. Usually, transforming code from one to the other is
        very simple.

        TOSSIM currently does not support gathering power
        measurements.

        <h1>Compiling TOSSIM</h1>

        <p>TOSSIM is a TinyOS library. Its core code lives in <tt><a
        href="../../../tos/lib/tossim">tos/lib/tossim</a></tt>. Every TinyOS
        source directory has an optional <tt>sim</tt> subdirectory,
        which contains simulation implementations of that package. For
        example, <tt><a
        href="../../../tos/chips/atm128/timersim">tos/chips/atm128/timer/sim</a></tt>
        contains TOSSIM implementations of some of the Atmega128 timer
        abstractions.</p>

        <p>To compile TOSSIM, you pass the <tt>sim</tt> option to make:</p>

        <pre>
          $ cd apps/Blink
          $ make micaz sim
        </pre>

        
        
        <p>Currently, the only platform TOSSIM supports is the
        micaz. You should see output similar to this:</p>
        <pre>
          mkdir -p build/micaz
            placing object files in build/micaz
            writing XML schema to app.xml
            compiling BlinkAppC to object file sim.o 
          ncc -c -fPIC -o build/micaz/sim.o -g -O0 -tossim -fnesc-nido-tosnodes=1000 -fnesc-simulate -fnesc-nido-motenumber=sim_node\(\)   -finline-limit=100000 -Wall -Wshadow -DDEF_TOS_AM_GROUP=0x7d -Wnesc-all -target=micaz -fnesc-cfile=build/micaz/app.c -board=micasb  -Wno-nesc-data-race BlinkAppC.nc   -fnesc-dump=components -fnesc-dump=variables -fnesc-dump=constants -fnesc-dump=typedefs -fnesc-dump=interfacedefs -fnesc-dump=tags -fnesc-dumpfile=app.xml
            compiling Python support into pytossim.o and tossim.o
          g++ -c -shared -fPIC -o build/micaz/pytossim.o -g -O0  /home/pal/src/tinyos-2.x/tos/lib/tossim/tossim_wrap.cxx -I/usr/include/python2.3 -I/home/pal/src/tinyos-2.x/tos/lib/tossim -DHAVE_CONFIG_H
          g++ -c -shared -fPIC -o build/micaz/tossim.o -g -O0  /home/pal/src/tinyos-2.x/tos/lib/tossim/tossim.c -I/usr/include/python2.3 -I/home/pal/src/tinyos-2.x/tos/lib/tossim
            linking into shared object ./_TOSSIMmodule.so
          g++ -shared build/micaz/pytossim.o build/micaz/sim.o build/micaz/tossim.o -lstdc++ -o _TOSSIMmodule.so
          copying Python script interface TOSSIM.py from lib/tossim to local directory
         </pre>

        <p>Compiling TOSSIM has five basic steps. Let's go through
        them one by one.</p>

        <h2>Writing an XML schema</h2>

        <pre>
          writing XML schema to app.xml
        </pre>

        <p>The first thing the TOSSIM build process does is use
        nesc-dump to produce an XML document that describes the
        application. Among other things, this document descibes the
        name and type of every variable.</p>

        <h2>Compiling the TinyOS Application</h2>

        <p>Besides introducing all of these new compilation steps, the
        <tt>sim</tt> option changes the include paths of the
        application. If the application has a series of includes</p>

        <pre>
          -Ia -Ib -Ic
        </pre>

        <p>Then the sim option transforms the list to</p>

        <pre>
          -Ia/sim -Ib/sim -Ic/sim -I%T/lib/tossim -Ia -Ib -Ic
        </pre>
          
        <p>This means that any system-specific simulation
        implementations will be used first, followed by generic TOSSIM
        implementations, followed by standard implementations. The
        <tt>sim</tt> option also passes a bunch of arguments to the
        compiler, so it knows to compile for simulation.</p>

        <p>The product of this step is an object file, <tt>sim.o</tt>,
        which lives in the platform's build directory. This object
        file has a set of C functions which configure the simulation
        and control execution.</p>

        <h2>Compiling the Programming Interface</h2>

        <pre>
            compiling Python support into pytossim.o and tossim.o
          g++ -c -shared -fPIC -o build/micaz/pytossim.o -g -O0 \
          /home/pal/src/tinyos-2.x/tos/lib/tossim/tossim_wrap.cxx \
          -I/usr/include/python2.3 -I/home/pal/src/tinyos-2.x/tos/lib/tossim \
          -DHAVE_CONFIG_H
          g++ -c -shared -fPIC -o build/micaz/tossim.o -g -O0 \
          /home/pal/src/tinyos-2.x/tos/lib/tossim/tossim.c \
          -I/usr/include/python2.3 -I/home/pal/src/tinyos-2.x/tos/lib/tossim
        </pre>
        
        <p>The next step compiles the support for the C++ and Python
        programming interfaces. The Python interface is actually built
        on top of the C++ interface. Calling a Python object calls a
        C++ object, which then calls TOSSIM through the C
        interface. <tt>tossim.o</tt> contains the C++ code, while
        <tt>pytossim.o</tt> contains the Python support. These files
        have to be compiled separately because C++ doesn't understand
        nesC, and nesC doesn't understand C++.</p>

        <h2>Building the shared object</h2>
        
        <pre>
            linking into shared object ./_TOSSIMmodule.so
          g++ -shared build/micaz/pytossim.o build/micaz/sim.o build/micaz/tossim.o -lstdc++ -o _TOSSIMmodule.so
        </pre>

        <p>The next to last step is to build a shared library that
        contains the TOSSIM code, the C++ support, and the Python
        support.</p>

        <h2>Copying Python Support</h2>
        
        <pre>
            copying Python script interface TOSSIM.py from lib/tossim to local directory
        </pre>

        <p>Finally, there is the Python code that calls into the
        shared object. This code exists in <tt>lib/tossim</tt>, and
        the make process copies it into the local directory.</p>

        
        <h1>Running TOSSIM with Python</h1>
        
        <p>Go into the <tt>RadioCountToLeds</tt> application and build
          TOSSIM:</p>

        <pre>
           $ cd tinyos-2.x/apps/RadioCountToLeds
           $ make micaz sim
        </pre>

        <p>We'll start with running a simulation in Python. You can either
          write a script and just tell Python to run it, or you can
          use Python interactively. We'll start with the latter. Fire
          up your Python interpreter:</p>

        <pre>
           $ python
        </pre>

        <p>You should see a prompt like this:</p>

        <pre>
           Python 2.3.4 (#1, Nov  4 2004, 14:13:38)
           [GCC 3.4.2 20041017 (Red Hat 3.4.2-6.fc3)] on linux2
           Type "help", "copyright", "credits" or "license" for more information.
           >>>
        </pre>

        <p>The first thing we need to do is import TOSSIM and create a
        TOSSIM object. Type</p>

        <pre>
           >>> from TOSSIM import *
           >>> t = Tossim([])
        </pre>
        
        <p>The square brackets are an optional argument that lets you
        access variables in the simulation. We'll get to how to use
        that later. In this case, we're telling TOSSIM that there are
        no variables that we want to look at. The way you run a TOSSIM
        simulation is with the <tt>runNextEvent</tt> function. For
        example:</p>

        <pre>
           >>> t.runNextEvent()
           0
        </pre>

        <p>When you tell TOSSIM to run the next event, it returns
        0. This means that there was no next event to run. The reason
        is simple: we haven't told any nodes to boot. This snippet of
        code will tell mote 32 to boot at time 45654 and run its first
        event (booting):</p>

        <pre>
           >>> m = t.getNode(32);
           >>> m.bootAtTime(45654);
           >>> t.runNextEVent()
           1
        </pre>

        <p>Now, <tt>runNextEvent</tt> returns 1, because there was an
        event to run. But we have no way of knowing whether the node
        has booted or not. We can find this out in one of two ways.
        The first is that we can just ask it:</p>

        <pre>
           >>> m.isOn()
           1
           >>> m.turnOff()
           >>> m.isOn()
           0
           >>> m.bootAtTime(560000)
           >>> t.runNextEvent()
           0
           >>> t.runNextEvent()
           1
        </pre>        

        <p>Note that the first <tt>runNextEvent</tt> returned 0. This
        is because when we turned the mote off, there was still an
        event in the queue, for its next timer tick. However, since
        the mote was off when the event was handled in that call,
        <tt>runNextEvent</tt> returned 0. The second call to
        <tt>runNextEvent</tt> returned 1 for the second boot event, at
        time 560000.</p>
        
        <h1>Debugging Statements</h1>
        
        <p>The second approach to know whether a node is on is to tell
        it to print something out when it boots. TOSSIM has a
        debugging output system, called <tt>dbg</tt>. There are four
        <tt>dbg</tt> calls:</p>

          <ul>
            <li><tt>dbg</tt>: print a debugging statement preceded by the node ID.</li>
            <li><tt>dbg_clear</tt>: print a debugging statement which is not preceded by the node ID. This allows you to easily print out complex data types, such as packets, without interspersing node IDs through the output.</li>
            <li><tt>dbgerror</tt>: print an error statement preceded by the node ID</li>
            <li><tt>dbgerror_clear</tt>: print an error statement which is not preceded by the node ID</li>
          </ul>

          
        <p>Go into <tt>RadioCountToLedsC</tt> and modify the <tt>Boot.booted</tt> event
          to print out a debug message when it boots, such as this:</p>

        <pre>
           event void Boot.booted() {
             call Leds.led0On();
             dbg("Boot", "Application booted.\n");
             call AMControl.start();
           }
        </pre>

        <p>Calls to the debugging calls take two or more
        parameters. The first parameter ("Boot" in the above example)
        defines the output <i>channel</i>. An output channel is simply
        a string. The second and subsequent parameters are the message
        to output. They are identical to a printf statement. For example
          RadioCountToLedsC has this call:

        <pre>
           event message_t* Receive.receive(message_t* bufPtr, void* payload, uint8_t len) {
             dbg("RadioCountToLedsC", "Received packet of length %hhu.\n", len);
             ...
           }
        </pre>

        which prints out the length of received packet as an 8-bit unsigned value (%hhu).</p>

        <p>Once you have added the debugging statement to the event,
        recompile the application with <tt>make micaz sim</tt> and
        start up your Python interpreter. Load the TOSSIM module and
        schedule a mote to boot as before:</p>
        
        <pre>
           >>> from TOSSIM import *
           >>> t = Tossim([])
           >>> m = t.getNode(32);
           >>> m.bootAtTime(45654);
        </pre>

        <p>This time, however, we want to see the debugging message
        that the mote has booted. TOSSIM's debugging output can be
        configured on a per-channel basis. So, for example, you can
        tell TOSSIM to send the "Boot" channel to standard output, but
        another channel, say "AM", to a file. Additionally, you can
        configureBy default, a channel has no destination, and so
        messages to it are discarded.</p>

        <p>In this case, we want to send the Boot channel to standard
        output. To do this, we need to import the <tt>sys</tt> Python
        package, which lets us refer to standard out. We can then tell
        TOSSIM to send Boot messages to this destination:
          
        <pre>
           >>> import sys
           >>> t.addChannel("Boot", sys.stdout);
           1
        </pre>

          The return value shows that the channel was added successfully. Run the first
          simulation event, and the mote boots:

        <pre>
           >>> t.runNextEvent()
           DEBUG (32): Application booted.
           1
        </pre>          </p>

        <p>The only difference between debug and error functions is
        the string output at the beginning of a message. Debug
        statements print <tt>DEBUG (n)</tt>, while error statements
        print <tt>ERROR (n)</tt>.</p>

        <p>A debugging statement can have multiple output
          channels. Each channel name is delimited by commas:

          <pre>
           event void Boot.booted() {
             call Leds.led0On();
             dbg("Boot,RadioCountToLedsC", "Application booted.\n");
             call AMControl.start();
           }
          </pre>

          If a statement has multiple channels and those channels
          share outputs, then TOSSIM only prints the message once. For
          example, if both the Boot channel and RadioCountToLedsC
          channel were connected to standard out, TOSSIM will only
          print one message. For example, this series of debug statements

          
          <pre>
           event void Boot.booted() {
             call Leds.led0On();
             dbg("Boot,RadioCountToLedsC", "Application booted.\n");
             dbg("RadioCountToLedsC", "Application booted again.\n");
             dbg("Boot", "Application booted a third time.\n");
             call AMControl.start();
           }
          </pre>

          when configured so

          <pre>
           >>> import sys
           >>> t.addChannel("Boot", sys.stdout)
           >>> t.addChannel("RadioCountToLedsC", sys.stdout)
          </pre>

          will print out this:

          <pre>
           DEBUG (32): Application booted.
           DEBUG (32): Application booted again.
           DEBUG (32): Application booted a third time.
          </pre></p>


        <p>A channel can have multiple outputs. For example, this
        script will tell TOSSIM to write RadioCountToLedsC messages to
        standard output, but to write Boot messages to both standard
        output and a file named <tt>log.txt</tt>:

          <pre>
           >>> import sys
           >>> f = open("log.txt", "w")
           >>> t.addChannel("Boot", f)
           >>> t.addChannel("Boot", sys.stdout)
           >>> t.addChannel("RadioCountToLedsC", sys.stdout)
          </pre>
        </p>

        <h1>Configuring a Network</h1>

        <p>When you start TOSSIM, no node can communicate with any
        other.  In order to be able to simulate network behavior, you
        have to specify a <i>network topology</i>. Internally, TOSSIM
        is structured so that you can easily change the underlying
        radio simulation, but that's beyond the scope of this
        tutorial. The default TOSSIM radio model is signal-strength
        based. You provide a graph to the simulator that describes the
        propagation strengths. You also specify noise floor, and
        receiver sensitivity. There are some very early results that
        describe current sensor platforms (e.g., the mica2) in these
        terms. Because all of this is through a scripting interface,
        rather than provide a specific radio model, TOSSIM tries to
        provide a few low-level primitives that can express a wide
        range of radios and behavior.</p>

        <p>You control the radio simulation through a Python Radio
        object:</p>

        
        <pre>
           >>> from TOSSIM import *
           >>> t = Tossim([])
           >>> r = t.radio()
           >>> dir(r)
           ['__class__', '__del__', '__delattr__', '__dict__', '__doc__',
           '__getattr__', '__getattribute__', '__hash__', '__init__',
           '__module__', '__new__', '__reduce__', '__reduce_ex__',
           '__repr__', '__setattr__', '__str__', '__swig_getmethods__',
           '__swig_setmethods__', '__weakref__', 'add', 'connected',
           'gain', 'remove', 'setNoise', 'this', 'thisown',
           <class 'TOSSIM.RadioPtr'>]
        </pre>          

        <p>The first set of methods (with the double underscores) are
        ones that you usually don't call. The important ones are at
        the end. They are:</p>

        <ul>
          <li><b>add(src, dest, gain)</b>: Add a link from <i>src</i>
          to <i>dest</i> with <i>gain</i>. When src transmits, dest
          will receive a packet attenuated by the gain value.</li>

          <li><b>connected(src, dest)</b>: Return whether there is a
          link from <i>src</i> to <i>dest</i>.</li>


          <li><b>gain(src, dest)</b>: Return the gain value of the
          link from <i>src</i> to <i>dest</i>.</li>
          
          <li><b>remove(src, dest)</b>: Remove the link from
          <i>src</i> to <i>dest</i>.</li>


          <li><b>setNoise(node, mean, variance)</b>: Set the noise
          floor at <i>node</i> to be a gaussian distribution with
          <i>mean</i> and <i>variance</i>.</li>

          <li><b>sensitivity()</b>: Return the receive sensitivity of
            the nodes.</li>

          <li><b>setSensitivity(val)</b>: Set the receive sensitivity
          of nodes to be <i>val</i>. The sensitivity is how much
          stronger a signal must be for it to be received
          uncorrupted. E.g., a sensitivity of 3.0 (the default value)
          means that a packet must be 3dBm greater than the sum of
          noise and concurrent transmissions for it to be received
          uncorrupted.</li>

          <li><b>threshold()</b>: Return the CCA threshold.</li>

          <li><b>setThreshold(val)</b>: Set the CCA threshold value in
            dBm.The default is -77.</li>
          
        </ul>

        <p>The Radio object only deals with physical layer
        propagation. The MAC object deals with the data link layer,
        packet lengths, and radio bandwidth. The default TOSSIM MAC
        object is for a CSMA protocol. You get a reference to the MAC
        object by calling mac() on a Tossim object:
          <pre>
           >>> mac = t.mac()
          </pre>

          The default MAC object has a large number of functions, for
          controlling backoff behavior, packet preamble length, radio
          bandwidth, etc. All time values are specified in terms of
          radio symbols, and you can configure the number of symbols
          per second and bits per symbol. By default, the MAC object
          is configured to act like the standard TinyOS 2.0 CC2420
          stack: it has 4 bits per symbol and 64k symbols per second,
          for 256kbps. This is a subset of the MAC functions that
          could be useful for changing backoff behavior. Every
          accessor function has a corresponding set function that
          takes an integer as a parameter. E.g., there's <tt>int
          initHigh()</tt> and <tt>void setInitHigh(int val)</tt>. The
          default value for each parameter is shown italicized in
          parentheses.  </p>

        <ul>
          <li><b>initHigh</b>: The upper bound of the initial backoff range. <i>(400)</i></li>
          <li><b>initLow</b>: The lower bound of the initial backoff range. <i>(20)</i></li>
          <li><b>high</b>: The upper bound of the backoff range. This is multiplied by the
          exponent base to the nth power, where n is the number of previous backoffs. So if the
          node had its initial backoff, then the upper bound is high * base, while if it
          is after the second backoff then the upper bound is high * base * base. <i>(160)</i></li>
          <li><b>low</b>: The lower bound of the backoff range. This is multiplied by the
          exponent base to the nth power, where n is the number of previous backoffs. So if the
          node had its initial backoff, then the upper bound is low * base, while if it
          is after the second backoff then the upper bound is low * base * base. <i>(20)</i></li>
          <li><b>symbolsPerSec</b>: The number of symbols per second that the radio can
          transmit. <i>(65536)</i></li>
          <li><b>bitsPerSymbol</b>: The number of bits per radio symbol. Multiplying this by
          the symbols per second gives the radio bandwidth. <i>(4)</i></li>
          <li><b>preambleLength</b>: How long a packet preamble is. This is added to the duration
          of transmission for every packet. <i>(12)</i></li>
          <li><b>exponentBase</b>: The base of the exponent used to calculate backoff. Setting it to
          2 provides binary exponential backoff. <i>(0)</i>.</li>
          <li><b>maxIterations</b>: The maximum number of times the radio will back off before
          signaling failure, zero signifies forever. <i>(0)</i>.</li>
          <li><b>minFreeSamples</b>: The number of times the radio must detect a clear channel
          before it will transmit. This is important for protocols like 802.15.4, whose synchonrous
          acknowledgments requires that this be greater than 1 (you could have sampled in the dead time
          when the radios are changing between RX and TX mode). <i>(2)</i></li>
          <li><b>rxtxDelay</b>: The time it takes to change the radio from RX to TX mode (or vice versa).<i>(32)</i></li>
          <li><b>ackTime</b>: The time it takes to transmit a synchonrous acknowledgment, not including the
          requisite RX/TX transition.<i>(34)</i></li>
        </ul>

        <p>Any and all of these configuration constants can be changed
        at compile time with #define directives. Look at
        <tt>tos/lib/tossim/sim_csma.h</tt>.</p>

        <p>Because the radio connectivity graph can be scripted, you
        can easily store topologies in files and then load the
        file. Alternatively, you can store a topology as a script.
        For example, this script will load a file which specifies each
          link in the graph as a line with three values, the source, the
          destination, and the gain, e.g.:

          <pre>
           1  2 -54.0
          </pre>

          means that when 1 transmits 2 hears it at -54 dBm. Create a file <tt>topo.txt</tt>
          that looks like this:</p>

        <pre>
           1  2 -54.0
           2  1 -55.0
           1  3 -60.0
           3  1 -60.0
           2  3 -64.0
           3  2 -64.0
        </pre>

        <p>This script will read such a file:

          <pre>
           >>> f = open("topo.txt", "r")
           >>> lines = f.readlines()
           >>> for line in lines:
           ...   s = line.split()
           ...   if (len(s) > 0):
           ...     print " ", s[0], " ", s[1], " ", s[2];
           ...     r.add(int(s[0]), int(s[1]), float(s[2]))
          </pre></p>
        
        
        <p>Now, when a node transmits a packet, other nodes will hear it.
        This is a complete script for simulating packet transmission with
          RadioCountToLedsC. Save it as a file <tt>test.py</tt>:</p>
        <pre>
           from TOSSIM import *
           import sys

           t = Tossim([])
           r = t.radio()
           f = open("topo.txt", "r")

           lines = f.readlines()
           for line in lines:
             s = line.split()
             if (len(s) > 0):
               print " ", s[0], " ", s[1], " ", s[2];
               r.add(int(s[0]), int(s[1]), float(s[2]))

           t.addChannel("RadioCountToLedsC", sys.stdout)
           t.addChannel("Boot", sys.stdout)

           t.getNode(1).bootAtTime(100001);
           t.getNode(2).bootAtTime(800008);
           t.getNode(3).bootAtTime(1800009);

           r.setNoise(1, -80.0, 5.0)
           r.setNoise(2, -80.0, 5.0)
           r.setNoise(3, -80.0, 5.0)

           for i in range(0, 100):
             t.runNextEvent()

        </pre>          

        <p>Run it by typing <tt>python test.py</tt>. You should see
          output that looks like this:</p>

        <pre>
  1   2   -54.0
  2   1   -55.0
  1   3   -22.1
DEBUG (1): Application booted.
DEBUG (1): Application booted again.
DEBUG (1): Application booted a third time.
DEBUG (2): Application booted.
DEBUG (2): Application booted again.
DEBUG (2): Application booted a third time.
DEBUG (3): Application booted.
DEBUG (3): Application booted again.
DEBUG (3): Application booted a third time.
DEBUG (1): RadioCountToLedsC: timer fired, counter is 1.
DEBUG (1): RadioCountToLedsC: packet sent.
DEBUG (2): RadioCountToLedsC: timer fired, counter is 1.
DEBUG (2): RadioCountToLedsC: packet sent.
DEBUG (3): RadioCountToLedsC: timer fired, counter is 1.
DEBUG (3): RadioCountToLedsC: packet sent.
DEBUG (1): Received packet of length 2.
DEBUG (3): Received packet of length 2.
DEBUG (2): Received packet of length 2.
DEBUG (1): RadioCountToLedsC: timer fired, counter is 2.
DEBUG (1): RadioCountToLedsC: packet sent.
DEBUG (2): RadioCountToLedsC: timer fired, counter is 2.
DEBUG (2): RadioCountToLedsC: packet sent.
DEBUG (3): RadioCountToLedsC: timer fired, counter is 2.
DEBUG (3): RadioCountToLedsC: packet sent.
DEBUG (1): Received packet of length 2.

        </pre>
          
        <h1>Variables</h1>

        <p>TOSSIM allows you to inspect variables in a running TinyOS
        program.
        </p>
      
        
<h1>Conclusions</h1>

This lesson has introduced radio communications TinyOS 2.x.

<a name=#related_docs>
<h1>Related Documentation</h1>

<ul>
<li>[1] <a href="../tep111.html">TEP 111: message_t</a>
<li>[2] <a href="../tep116.html">TEP 116: Packet Protocols</a>
</ul>

<hr>

<p><b><a href="lesson6.html">Next Lesson &gt;</a></b> |&nbsp; <b><a
 href="index.html">Top</a></b>

</body>
</html>
