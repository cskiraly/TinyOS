<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
  <title>TinyOS Tutorial Lesson 1: TinyOS Component Model</title>
  <link href="../../stylesheets/tutorial.css" rel="stylesheet" type="text/css">
</head>

<body>

<div class="title">Lesson 1: Getting Started with TinyOS and nesC</div>
<div class="subtitle">Last updated June 12 2006</div>

      <p>This lesson introduces the basic concepts of the component model
	used by TinyOS, and the nesC component syntax.</p>
      
      <h1>Introduction</h1>
      
      <p>TinyOS is written in nesC, an extension of the C language
	designed to support the resource-challenged embedded systems
	space.  nesC's extensions support an efficient yet robust
	component model, and a concurrency model based on
	run-to-completion tasks and interrupt handlers. This lesson
	introduces the TinyOS/nesC component model, and the next
	lesson introduces the TinyOS/nesC concurrency model.</p>

      <h1>Compiling and Installing</h1>
      
      <p>As a first exercise, you'll compile and install a very simple
	TinyOS application called Blink. If you don't have mote
	hardware, you can compile it for TOSSIM, the TinyOS simulator.</p>
      
      <p>You compile TinyOS applications with the program
	<tt>make</tt>.  TinyOS uses a powerful and extensible make
	system that allows you to easily add new platforms and
	compilation options.  The makefile system definitions are
	located in tinyos-2.x/support/make.</p>

      <p>The first thing to check is that you have the TinyOS build system
	enabled. This involves the MAKERULES environment variable. In a shell,
	type</p>

	<pre>
  printenv MAKERULES
        </pre>

      <p>You should see <tt>/opt/tinyos-2.x/support/make/Makerules</tt>. If
	your TinyOS tree is installed somewhere besides the standard place,
	you might not see <tt>/opt</tt>, but rather a different initial path.
	If MAKERULES is not set (printenv prints nothing), you need to set it.
	Depending on your shell, this involves using either <tt>export</tt> (bash)
	or <tt>setenv</tt> (csh, tcsh). If you don't know about shell environment
	variables, this
	<A HREF="http://www.ee.surrey.ac.uk/Teaching/Unix/unix8.html">tutorial</A>
	should help.</p>
	
      <p>The make command to compile a TinyOS application is 
	<code>make</code>&nbsp;<i>[platform]</i>, executed from the 
	application's directory. To compile Blink, go the <code>apps/Blink</code>
	directory and depending on which hardware you have, type <tt>make micaz</tt>,
	<tt>make mica2</tt>, <tt>make telosb</tt>, or, for simulation, type
	<tt>make micaz sim</tt>.</p>. You should see output such as this:

      <pre>
dark /root/src/tinyos-2.x/apps/Blink -4-> make telosb
mkdir -p build/telosb
    compiling BlinkAppC to a telosb binary
ncc -o build/telosb/main.exe -Os -O -mdisable-hwmul -Wall -Wshadow
-DDEF_TOS_AM_GROUP=0x7d -Wnesc-all -target=telosb -fnesc-cfile=build/telosb/app.c
-board=   BlinkAppC.nc -lm 
    compiled BlinkAppC to build/telosb/main.exe
            2782 bytes in ROM
              61 bytes in RAM
msp430-objcopy --output-target=ihex build/telosb/main.exe build/telosb/main.ihex
    writing TOS image
      </pre>

      <p>If you compile for TOSSIM, you will see a much longer message,
	as building TOSSIM requires several steps, such as building shared
	libraries and scripting support.</p>

      <h2>Installing on a mica-family mote (micaz, mica2)</h2>
      
      <p>Now that we've compiled the application it's time to program the
	mote and run it. This example will use the Mica mote and the
	parallel-port-based programming board (<span
	  style="font-family: monospace;">mib500</span>). Instructions on how to
	use other programming boards and telosb motes are <a href="programmers.html">here</a>.
	To download your program onto the mote, place the mote board (or mote
	and sensor stack) into the bay on the programming board, as shown
	below. You can either supply a 3 volt supply to the connector on the
	programming board or power the node directly. The red LED (labeled D2)
	on the programming board will be on when power is supplied. If you are
	using batteries to power the mote, be sure the mote is switched on (the
	power switch should be towards the connector). </p>
      <p>Plug the 32-pin connector into the parallel port of a computer
	configured with the TinyOS tools, using a standard DB32 parallel port
	cable. </p>
      <center>
	<table border="0" cellspacing="2" cellpadding="3" hspace="4">
	  <tbody>
	    <tr>
	      <td><img src="img/mica-offboard.jpg" height="240" width="320"></td>
	      <td><img src="img/mica-onboard.jpg" height="240" width="320"></td>
	    </tr>
	    <tr>
	      <td><i>Mica mote next to the programming board</i></td>
	      <td><i>Mica mote connected to the programming board</i></td>
	    </tr>
	  </tbody>
	</table>
      </center>
      <p>Type: <tt>make micaz reinstall</tt>. If the installation is successful you
	should see something like the following: </p>
      
      <pre>
cp build/micaz/main.srec build/micaz/main.srec.out
    installing micaz binary with dapa
uisp -dprog=dapa --wr_fuse_h=0xd9 -dpart=ATmega128 --wr_fuse_e=ff  --erase 
pulse
Atmel AVR ATmega128 is found.
Erasing device ...
pulse
Reinitializing device
Atmel AVR ATmega128 is found.

Fuse High Byte set to 0xd9

Fuse Extended Byte set to 0xff
sleep 1      
uisp -dprog=dapa --wr_fuse_h=0xd9 -dpart=ATmega128 --wr_fuse_e=ff  --upload if=build/micaz/main.srec.out
pulse
Atmel AVR ATmega128 is found.
Uploading: flash

Fuse High Byte set to 0xd9

Fuse Extended Byte set to 0xff
sleep 1      
uisp -dprog=dapa --wr_fuse_h=0xd9 -dpart=ATmega128 --wr_fuse_e=ff  --verify if=build/micaz/main.srec.out
pulse
Atmel AVR ATmega128 is found.
Verifying: flash

Fuse High Byte set to 0xd9

Fuse Extended Byte set to 0xff
rm -f build/micaz/main.exe.out build/micaz/main.srec.out 
      </pre>

      <h2>Installing on telos-family mote (telosa, telosb)</h2>

      <p>Because Telos motes are USB devices, they register with
         your OS when you plug them in. Typing <code>motelist</code>
         will display which nodes are currently plugged in:</p>
<pre>
$ motelist
Reference  CommPort   Description
---------- ---------- ----------------------------------------
UCC89MXV   COM4       Telos (Rev B 2004-09-27)
</pre>

<p><i>motelist</i> tells you which ports have motes attached. In 
this case a TelosB mote is connected to COM port 4. Now you can 
install the application using:</p>

<pre>
  make telosb reinstall.2 bsl,3
</pre>

<p>This would compile an image suitable for the telosb platform and install 
it with a mote ID of 2 using the <code>tos-bsl</code> loader on 
COM port 4 (the bsl argument uses n-1 notation: the COM port is 4 but 
the argument on the make line is 3 (4-1)). Again, see the Getting Started 
Guide for your chosen platform for the exact make parameters.</p>

<p>You should see something like this scroll by:</p>

<pre>
mkdir -p build/telosb
    compiling BlinkAppC to a telosb binary
ncc -o build/telosb/main.exe -Os -O -mdisable-hwmul -Wall -Wshadow -DDEF_TOS_AM_GROUP=0x7d -Wnesc-all -target=telosb -fnesc-cfile=build/telosb/app.c -board=   BlinkAppC.nc -lm 
    compiled BlinkToRadioAppC to build/telosb/main.exe
            2782 bytes in ROM
             61 bytes in RAM
msp430-objcopy --output-target=ihex build/telosb/main.exe build/telosb/main.ihex
    writing TOS image
tos-set-symbols --objcopy msp430-objcopy --objdump msp430-objdump --target ihex build/telosb/main.ihex build/telosb/main.ihex.out-2 TOS_NODE_ID=2 ActiveMessageAddressC$addr=2
    found mote on COM4 (using bsl,auto)
    installing telosb binary using bsl
tos-bsl --telosb -c 16 -r -e -I -p build/telosb/main.ihex.out-2
MSP430 Bootstrap Loader Version: 1.39-telos-8
Mass Erase...
Transmit default password ...
Invoking BSL...
Transmit default password ...
Current bootstrap loader version: 1.61 (Device ID: f16c)
Changing baudrate to 38400 ...
Program ...
2782 bytes programmed.
Reset device ...
rm -f build/telosb/main.exe.out-2 build/telosb/main.ihex.out-2
</pre>

      <p>This assumes you're running Windows. Things are slightly
	different on Linux. Instead of COM4 you'll find a numbered
	"file" in the /dev directory. The actual name of this file
	varies from distribution to distribution and depends on how
	the motes are physically connected  (i.e., via serial or USB).</p>

<pre>
$ motelist
Reference  CommPort   Description
---------- ---------- ----------------------------------------
UCC89MXV   /dev/ttyUSB3 Telos (Rev B 2004-09-27)
</pre>

      <p>You use the same command to install, except you don't substract 1. 
	The ports are already numbered starting at 0.</p>

      <pre>
  make telosb install.2 bsl,/dev/ttyUSB3
      </pre>
	      
      <h2>Installation options</h2>
      
      <p>You can now test the program by unplugging the mote from the
	programming board and turning on the power switch (if it's not already
	on). With any luck the three LEDs should be displaying a counter
	incrementing at 4Hz.</p>
      
      <p>The <tt>reinstall</tt> command told the make system to
	install the currently compiled binary: it skips the
	compilation process. Type <tt>make clean</tt> to clean up all
	of the compiled binary files, then type <tt>make micaz install</tt>
	This will recompile Blink and install it on one action.</p>
      
      <p>Networking almost always requires motes to have unique identifiers.
	When you compile a TinyOS application, it has a default unique
	identifier of 1. To give a node a different identifier, you can specify
	it at installation. For example, if you type <tt>make micaz install.5</tt>
	or <tt>make micaz reinstall.5</tt>, you will install the application
	on a node and give it 5 as its identifier.</b></p>
	  
<h1>Components and Interfaces</h1>

      <p>Now that you've installed Blink, let's look at how
	it works. Blink, like all TinyOS code, is written
	in nesC, which is C with some additional language
	features for components and concurrency.</p>
		
      <p>A nesC application consists of one or more <i>components</i>
	assembled, or <i>wired</i>, to form an application executable.
	Components define two scopes: one for their specification which
	contains the names of their <i>interfaces</i>, and a second scope for their
	implementation. A component <i>provides</i> and <i>uses</i>
	interfaces. The provided interfaces are intended to represent
	the functionality that the component provides to its user in its
	specification; the used interfaces represent the functionality the
	component needs to perform its job in its implementation.</p>
      
      <p>Interfaces are bidirectional: they specify a set of
	<i>commands</i>, which are functions to be implemented by the
	interface's provider, and a set of <i>events</i>, which are functions
	to be implemented by the interface's user. For a component to call the
	commands in an interface, it must implement the events of that
	interface. A single component may use or provide multiple interfaces
	and multiple instances of the same interface.</p>
      
      <p>The set of interfaces which a component provides together with the
	set of interfaces that a component uses is considered that component's
	<i>signature</i>.</p>
	      
      <h2>Configurations and Modules</h2>
      
      <p>There are two types of components in nesC: <i>modules</i> and
	<i>configurations</i>. Modules provide the implementations of one or more
	interfaces. Configurations are used to assemble other components
	together, connecting interfaces used by components to interfaces
	provided by others. Every nesC
	application is described by a top-level configuration that wires
	together the components inside.</p>

      <h1>Blink: An Example Application</h1>

      <p>Let's look at a concrete example:
	<tt><a href="../../../apps/Blink">Blink</a></tt> in the TinyOS
	tree. As you saw, this application displays a counter on the
	three mote LEDs. In actuality, it simply causes the LED0 to to turn on and off at
	.25Hz, LED1 to turn on and off at .5Hz, and LED2 to turn on and off at
	1Hz. The effect is as if the three
	LEDs were displaying a binary count of one to seven every two
	seconds. </p>

<p>Blink is composed of two <b>components</b>: a <b>module</b>, called
"<tt>BlinkC.nc</tt>", and a <b>configuration</b>, called
"<tt>BlinkAppC.nc</tt>".  Remember that all applications require a
top-level configuration file, which is typically named after the
application itself. In this case <tt>BlinkApp.nc</tt> is the
configuration for the Blink application and the source file that the
nesC compiler uses to generate an executable file. <tt>BlinkC.nc</tt>,
on the other hand, actually provides the <i>implementation</i> of the
Blink application. As you might guess, <tt>BlinkAppC.nc</tt> is used
to wire the <tt>BlinkC.nc</tt> module to other components that the
Blink application requires. </p>

<p>The reason for the distinction between modules and configurations
is to allow a system designer to build applications out of existing
implementations. For example, a designer could provide a configuration
that simply wires together one or more modules, none of which she
actually designed.  Likewise, another developer can provide a new set
of library modules that can be used in a range of applications. </p>

<p>Sometimes (as is the case with <tt>BlinkAppC</tt> and
<tt>BlinkC</tt>) you will have a configuration and a module that go
together. When this is the case, the convention used in the TinyOS
source tree is:</p>


<CENTER>
<table border="1"  cellspacing="1" cellpadding="1">
<tbody>

<tr>
<td>File Name </td>
<td>File Type </td>
</tr>

<tr>
<td><tt>Foo.nc</tt></td>
<td>Interface </td>
</tr>

<tr>
<td><tt>Foo.h</tt></td>
<td>Header File</td>
</tr>
	  
<tr>
<td><tt>FooC.nc </tt></td>
<td>Public Module</td>
</tr>

<tr>
<td><tt>FooP.nc</tt></td>
<td>Private Module</td>
</tr>


</tbody>
</table>
</CENTER>

<p>While you could
name an application's implementation module and associated top-level
configuration anything, to keep things simple we suggest that you
adopt this convention in your own code. There are several other 
conventions used in TinyOS;  
<a href="../tep3.html">TEP 3</a>
specifies the coding standards and best current practices.

<h1>The BlinkAppC.nc Configuration</h1>

<p>The nesC compiler compiles a nesC application when given the file
containing the top-level configuration. Typical TinyOS applications
come with a standard Makefile that allows platform selection and
invokes ncc with appropriate options on the application's top-level
configuration.

<p>Let's look at <tt>BlinkAppC.nc</tt>, the configuration for this
application first:

<pre></pre>
<prehead>apps/Blink/BlinkAppC.nc:</prehead>
<pre>
configuration BlinkAppC {
}
implementation {  
  components MainC, BlinkC, LedsC;
  components new TimerMilliC() as Timer0;
  components new TimerMilliC() as Timer1;
  components new TimerMilliC() as Timer2;

  BlinkC -> MainC.Boot;
  MainC.SoftwareInit -> LedsC;
  BlinkC.Timer0 -> Timer0;
  BlinkC.Timer1 -> Timer1;
  BlinkC.Timer2 -> Timer2;
  BlinkC.Leds -> LedsC;
}
</pre>

<p>The first thing to notice is the key word <tt>configuration</tt>,
which indicates that this is a configuration file. The first two
lines,

<pre></pre>
<prehead>apps/Blink/BlinkAppC.nc:</prehead>
<pre>
configuration BlinkAppC {
}
</pre>

simply state that this is a configuration called <tt>BlinkAppC</tt>.
Within the empty braces here it is possible to specify <tt>uses</tt>
and <tt>provides</tt> clauses, as with a module. This is important to
keep in mind: a configuration can use and provide interfaces. Said
another way, not all configurations are top-level applications.

<p>The actual configuration is implemented within the pair of curly
brackets following the key word <tt>implementation </tt>. The
<tt>components</tt> lines specify the set of components that this
configuration references. In this case those components are
<tt>Main</tt>, <tt>BlinkC</tt>,
<tt>LedsC</tt>, and three instances of a timer component called
<tt>TimerMilliC</tt> which will be referenced as Timer0, Timer1,
and Timer2<a href="#timermillic_footnote">(1)</a>. This is accomplished
via the <i>as</i> keyword which is simply an alias<a href="#hint10">(2)</a>. 

<p>As we continue reviewing the BlinkAppC application, keep in mind that the
BlinkAppC component is not the same as the BlinkC component. Rather,
the BlinkAppC component is composed of the BlinkC component along with
MainC and LedsC.

<p>The remainder of the BlinkAppC configuration consists of connecting
interfaces used by components to interfaces provided by others. The
<tt>MainC.Boot</tt> and <tt>MainC.SoftwareInit</tt> interfaces are
part of TinyOS's boot sequence and will be covered in detail in Lesson
3. Suffice it to say that these wirings enable the LEDs and Timers to
be initialized.

<p>The last four lines wire interfaces that the BlinkC component
<i>uses</i> to interfaces that the TimerMilliC and LedsC
components <i>provide</i>. To fully understand the semantics of these
wirings, it is helpful to look at the BlinkC module's definition and
implementation.

<h1>The BlinkC.nc Module</h1>

<pre></pre>
<prehead>apps/Blink/BlinkC.nc:</prehead>
<pre>
module BlinkC {
  uses interface Timer&lt;TMilli&gt; as Timer0;
  uses interface Timer&lt;TMilli&gt; as Timer1;
  uses interface Timer&lt;TMilli&gt; as Timer2;
  uses interface Leds;
  users interface Boot;
}
implementation
{
  // implementation code omitted
}
</pre>

<p>The first part of the module code states that this is a module
called <tt>BlinkC</tt>and declares the interfaces it provides and
uses.&nbsp; The <tt>BlinkC</tt>&nbsp; module <b>uses</b> three
instances of the interface <tt>Timer&lt;TMilli&gt;</tt> using the
names Timer0, Timer1 and Timer2 (the <tt>&lt;TMilli&gt;</tt> syntax
simply supplies the generic Timer component with the required timer
precision). Lastly, the <tt>BlinkC</tt>
module also uses the Leds and Boot interfaces. This means that BlinkC
may call any command declared in the interfaces it uses and must also
implement any events declared in those interfaces.

<p>After reviewing the interfaces used by the <tt>BlinkC</tt>
component, the semantics of the last four lines in
<tt>BlinkAppC.nc</tt> should become clearer.  The line
<tt>BlinkC.Timer0 -&gt; Timer0</tt> wires the three
<tt>Timer&lt;TMilli&gt;</tt> interface used by <tt>BlinkC</tt> to the
<tt>Timer&lt;TMilli&gt;</tt> interface provided the three
<tt>TimerMilliC</tt> component. The <tt>BlinkC.Leds -&gt;
LedsC</tt> line wires the <tt>Leds</tt> interface used by the
<tt>BlinkC</tt> component to the <tt>Leds</tt> interface provided by
the <tt>LedsC</tt> component.

<p>NesC uses arrows to bind interfaces to one another.  The right arrow
(<tt>A-&gt;B</tt>) as "A wires to B". The left side of the arrow (A)
is a user of the interface, while the right side of the arrow (B) is
the provider. A full wiring is <tt>A.a-&gt;B.b</tt>, which means
"interface a of component A wires to interface b of component B."
Naming the interface is important when a component uses or provides multiple
instances of the same interface. For example, BlinkC uses three instances of
Timer: Timer0, Timer1 and Timer2.

When a component only has one instance
of an interface, you can elide the interface name. For example, returning
to BlinkAppC:

<pre></pre>
<prehead>apps/Blink/BlinkAppC.nc:</prehead>
<pre>
configuration BlinkAppC {
}
implementation {  
  components MainC, BlinkC, LedsC;
  components new TimerMilliC() as Timer0;
  components new TimerMilliC() as Timer1;
  components new TimerMilliC() as Timer2;

  BlinkC -> MainC.Boot;
  MainC.SoftwareInit -> LedsC;
  BlinkC.Timer0 -> Timer0;
  BlinkC.Timer1 -> Timer1;
  BlinkC.Timer2 -> Timer2;
  BlinkC.Leds -> LedsC;
}
</pre>

<p>The interface name Leds does not have to be included in LedsC:</p>

<pre>
  BlinkC.Leds -> LedsC; // Same as BlinkC.Leds -> LedsC.Leds
</pre>

<p>Because BlinkC only uses one instance of the Leds interface, this
line would also work:</p>

<pre>
  BlinkC -> LedsC.Leds; // Same as BlinkC.Leds -> LedsC.Leds
</pre>

<p>As the TimerMilliC components each provide a single instance of Timer,
it does not have to be included in the wirings:</p>

<pre>
  BlinkC.Timer0 -> Timer0;
  BlinkC.Timer1 -> Timer1;
  BlinkC.Timer2 -> Timer2;
</pre>

<p>However, as BlinkC has three instances of Timer, eliding the name
on the user side would be a compile-time error, as the compiler would
not know which instance of Timer was being wired:</p>

<pre>
  BlinkC -> Timer0.Timer;  // Compile error!
</pre

<p>The direction of a wiring arrow is always from a user to a
provider. If the provider is on the left side, you can also
use a left arrow:</p>

<pre>
  Timer0 <- BlinkC.Timer0; // Same as BlinkC.Timer0 -> Timer0;
</pre>

<p>For ease of reading, however, most wirings are left-to-right.</p>

<h1>Visualizing a Component Graph</h1>

<p>Carefully engineered TinyOS systems often have many layers of configurations,
each of which refines the abstraction in simple way, building something robust
with very little executable code. Getting to the modules underneath
-- or just navigating the layers -- with a text editor can be laborious.
To aid in this process, TinyOS and nesC have a documentation feature called
nesdoc, which generates documentation automatically from source code. In
addition to comments, nesdoc displays the structure and composition of
configurations.</p>

<p>To generate documentation for an application, type</p>

<pre>
  make <platform> docs
</pre>

<p>You should see a long list of interfaces and components stream by. If you
see the error message</p>

<pre>sh: dot: command not found</pre>

<p>then you need to <A HREF="http://www.graphviz.org/Download..php">install
graphviz</A>, which is the program that draws the component graphs.</p>

<p>Once you've generated the documentation, go to <tt>doc/nesdoc</tt>. You
should see a directory for your platform: open its <tt>index.html</tt>, and
you'll see a list of the components and interfaces for which you've
generated documentation. For example, if you generated documentation
for Blink on the telos platform, you'll see documentation for interfaces
such as Boot, Leds, and Timer, as well as some from the underlying hardware
implementations, such as Msp430TimerEvent and HplMsp430GeneralIO.</p>

<p>In the navigation panel on the left, components are below interfaces.
Click on BlinkAppC, and you should a figure like this: </p>

<CENTER>
  <IMG SRC="img/BlinkAppC.gif">
</CENTER>

<p>In nesdoc diagrams, a single box is a module and a double box is a
configuration. Dashed border lines denote that a component is a generic:</p>
<CENTER>
<TABLE CELLPADDING=6 BORDER=1>
  <TR>
    <td></td>
    <td><b>Singleton</b></td>
    <td><b>Generic</b></td>
  </TR>
  <TR>
    <td>Module</td>
    <td><IMG SRC="img/singleton-module.gif"></td>
    <td><IMG SRC="img/generic-module.gif"></td>
  </TR>
  <TR>
    <td>Configuration</td>
    <td><IMG SRC="img/singleton-configuration.gif"></td>
    <td><IMG SRC="img/generic-configuration.gif"></td>
  </TR>
</TABLE>
</CENTER>
<p>Lines denote wirings, and shaded ovals denote interfaces
that a component provides or uses. You can click on the components
in the graph to examine their internals. Click on MainC, which shows
the wirings for the boot sequence:</p>

<CENTER>
  <IMG SRC="img/tos.system.MainC.gif">
</CENTER>

<p>Shaded ovals denote wireable interfaces.
Because MainC provides the Boot interface and uses the Init (as
SoftwareInit) interface, it has two shaded ovals. Note the direction
of the arrows: because it uses SoftwareInit, the wire goes out from
RealMainP to SoftwareInit, while because it provides Boot, the wire
goes from Boot into RealMainP. The details of MainC aren't too important
here, and we'll be looking at it in greater depth in
<A HREF="lesson3.html">lesson 3</A>
(you can also read <A HREF="../tep107.html">TEP 107</A> for details),
but looking at the components you can get a sense of what it does: it
controls the scheduler, initializes the hardware platform, and
initializes software components.</p>

<h1>Conclusion</h1>

<p>This lesson has introduced the concepts of the TinyOS component
model: configurations, modules, interfaces and wiring.  It showed
how applications are built by wiring components together. The next
lesson continues with Blink, looking more closely at modules,
including the TinyOS concurrency model and executable code.

<p>
<a name=#related_docs>
<h1>Related Documentation</h1>
</a>
<ul>
<li> mica mote Getting Started Guide at <a href="http://www.xbow.com">Crossbow</a>
<li> telos mote Getting Started Guide for <a href="http://www.moteiv.com">Moteiv</a>
<li> <a href="https://sourceforge.net/projects/nescc">nesc at sourceforge</a>
<li> <a href="http://nescc.sourceforge.net/papers/nesc-ref.pdf">NesC reference manual</a>
<li> <a href="http://csl.stanford.edu/~pal/pubs/tinyos-programming-1-0.pdf">TinyOS Programming Guide</a>
<li> <a href="../tep3.html">TEP 3: TinyOS Coding Conventions</a>
<li> <a href="../tep102.html">TEP 102: Timers</a>
<li> <a href="../tep106.html">TEP 106: Schedulers and Tasks</a>
<li> <a href="../tep107.html">TEP 106: TinyOS 2.x Boot Sequence</a>
</ul>

<p>
<hr>

<p><a name="timermillic_footnote">(1)</a> The TimerMilliC
component is a <i>generic component</i> which means that, unlike
non-generic components, it can be instantiated more than once.
Generic components can take typed arguments and in this case, that
typed argument defines the timer's required precision.  A full
explanation of generic components is outside this document's scope,
but you can read about them in <!-- TODO: Need to update this link to a real file><a
href="../../nesc/user/generics-1.2.txt"> -->the nesc generic component
documentation</a>.

<p><a name="hint10">(4)</a>
<b>Programming Hint 10:</b> Use the <i>as</i> keyword liberally. From  
<a href="http://csl.stanford.edu/~pal/pubs/tinyos-programming-1-0.pdf"><i>TinyOS Programming</i></a>


<!-- Begin footer -->
<br>
<hr>
<center>
<p>&lt;&nbsp;<b><a href="index.html">Top</a></b> 
&nbsp;|&nbsp; <b><a href="lesson2.html">Next Lesson </a>&nbsp;&gt;</b>
</center>

</body>
</html>
