==============================================
Permanent Data Storage (Flash)
==============================================

:TEP: 103
:Group: Core Working Group 
:Type: Documentary
:Status: Draft
:TinyOS-Version: 2.x
:Author: David Gay, Jonathan Hui

:Draft-Created: 27-Sep-2004
:Draft-Version: $Revision: 1.1.2.8 $
:Draft-Modified: $Date: 2006-06-07 23:11:27 $
:Draft-Discuss: TinyOS Developer List <tinyos-devel at mail.millennium.berkeley.edu>


.. Note::

   This memo documents a part of TinyOS for the TinyOS Community, and
   requests discussion and suggestions for improvements.  Distribution
   of this memo is unlimited. This memo is in full compliance with
   TEP 1.

Abstract
====================================================================

This memo documents a set of hardware-independent, non-volatile
storage interfaces for TinyOS 2.x, and the HPL and HAL layers for
various flash chips.


1. Introduction
====================================================================

There are three different flash chip families under use or
consideration for TinyOS platforms: the Atmel AT45DB family (Mica
family, Telos rev. A), the ST M25P family (Telos rev. B, eyes) and the
Intel Strataflash (Intel Mote2).  All three are "NOR" flash chips, but
the AT45DB has fairly different characteristics (see below). There
also "NAND" flash chips which have rather different tradeoffs from NOR
flash. Compact flash/etc cards use NAND flash but present a disk-like
block interface.

A common restriction of flash technology is that each bit can only be
written once between erases. The table below summarizes the
differences between the various flash technologies::


		   NOR                AT45DB         NAND

  Erase	       :  Slow (seconds)      Fast (ms)	     Fast (ms)
  Erase unit   :  Large (64KB-128KB)  Small (256B)   Medium (8K-32KB)
  Writes       :  Slow (100s kB/s)    Slow (60kB/s)  Fast (MBs/s)
  Write unit   :  1 bit               256B           100's of bytes
  Bit-errors   :  Low                 Low            High (requires ECC, 
                                                     bad-block mapping)
  Read	       :  Fast*               Slow+I/O bus   Fast (but limited by 
                                                     I/O bus)
  Erase cycles :  10^4 - 10^5         10^4 **        10^5 - 10^7
  Intended use :  Code storage        Data storage   Data storage

  *  Intel Mote2 NOR flash is memory mapped (reads are very fast and can
     directly execute code)
  ** Or infinite? Data sheet just says that every page within a sector
     must be written every 10^4 writes within that sector

From the power consumption for erasing and writing, we can derive an
energy cost/byte written (for NAND flash, taken from a Samsung
datasheet):

  Energy/byte:	  1uJ                 1uJ            .01uJ

Energy/byte for reads appears to depend mostly on how long the read
takes (the power consumptions are comparable), i.e., on the efficiency
of the bus + processor.

2. Non-Volatile Storage Abstraction in TinyOS 2.x 
===================================================================

The very significant differences between the flash chips used in TinyOS,
and lack of RAM to hide these differences, preclude common, low-level HIL
interfaces such as a disk-like block interface. Instead, we propose that
the HIL interfaces correspond to high-level storage services useful for
sensor network applications. We have identified three storage abstractions:
large objects, small objects, and logs. We envision separate implementations
of these abstractions for each class of storage chip; these implementations
will be found in the tos/chips/CHIPNAME hierarchy.

Rather than provide a general-purpose file system with variable-sized
files, we assume the flash is divided into fixed-size volumes, with
each volume dedicated to holding a single instance of one of the
abstractions (a large object, a small object or a log). We believe this
restrictive approach is practical in the single-application model of
TinyOS.

2.1 Large objects:
------------------------------------------------------------------

A large object ranges from a few kilobytes upwards. A large object
must be erased before use. Each byte in a large object can only
written once after each erase. A large object must be committed
to ensure it survives a reboot or crash. After a commit, no more
writes may be performed.

  - Size: large
  - Reads: random
  - Writes: random (each byte written at most once)
  - Failure model: no fault tolerance (crash before commit leads to
    object loss)
  - Other: a commit operation terminates writes, a validate operation
    checks the object.

Examples: program storage, message buffering in delay-tolerant-networking

2.2 Large sequential objects
------------------------------------------------------------------
       
Some applications (e.g., low-rate data collection) can use a large
sequential object to save their results in a reliable fashion. A large
sequential object can be circular.

  - Size: large
  - Reads: from memorized write points or beginning
  - Writes: sequential, object is linear or circular
  - Failure model: writes are atomic, failure during/between writes does
    not lead to whole object loss, but may lead to loss of some entries
    (but see sync)
    Note: failure during write may lead to (minor) capacity reduction
  - Other: sync: guarantees already written data will not be lost to
    (crash-style) failure

Example: logs.

2.3 Small objects:
------------------------------------------------------------------

A small object may be only a few hundred bytes. Small objects support
random reads and writes and simple transactional behaviour (each read is a
separate transaction, all writes up to a commit form a single transaction).

  - Size: small
  - Reads: random, read data as of last commit
  - Writes: random, rewrite ok
  - Failure model: failure during/between writes does not lead to object 
    loss (at reboot, object will contain state as of the most recent
    successful commit)
  - Other: commit operation ensures all writes since last commit become
    permanent

Example: configuration data.

3. HPL/HAL/HIL Architecture
====================================================================

The proposed architecture aligns with the three-layer Hardware
Abstraction Architecture (HAA). This document briefly presents
the components and interfaces; for full details see the nesdoc
comments in the referenced components and interfaces.

3.1 Hardware Presentation Layer (HPL)
--------------------------------------------------------------------

The flash HPL has a chip-dependent, system-independent interface. The
implementation of this HPL is system-dependent. The flash HPL SHOULD be
stateless. In many cases, families of flash chips can share a common HPL
interface.

Some examples:

- The Atmel AT45DB family HPL is: ::

    configuration HplAt45dbC {
      provides interface;
    } ...

  The ``HplAt45db`` interface has flash->buffer, buffer->flash, compare
  buffer to flash, erase page, read, compute CRC, and write operations.  A
  generic, system-independent implementation of the HPL
  (``HplAt45dbByteC``) is included allowing platforms to just provide SPI
  and chip selection interfaces.

  Different members of the AT45DB family are supported by specifying a few
  constants (number of pages, page size).

- The M25P family HPL is: ::

    configuration Stm25pSpiC {
      provides interface Init;
      provides interface Resource;
      provides interface Stm25pSpi;
    }

   The ``Stm25pSpi`` interface has read, write, compute CRC, sector erase
   and block erase operations. The implementation of this HPL is
   system-independent, built over a few system-dependent components
   providing SPI and chip selection interfaces.

Note that these two examples have different resource management policies:
the AT45DB encapsulates resource acquisition and release within each
operation, while the M25P family requires that HPL users acquire and
release the resource itself.

3.2 Hardware Adaptation Layer (HAL)
--------------------------------------------------------------------

The flash HAL has a chip-dependent, system-independent interface and
implementation. Flash families with a common HPL SHOULD have a common
HAL. Flash HAL's SHOULD expose a ``Resource`` interface and automatically
power-manage the underlying flash chip. Finally, the flash HAL SHOULD
provide a way to access the volume information specified by the
programmer (see Section 3.3a). This allows users to build new flash
abstractions that interact cleanly with the rest of the flash system.
Next, we show a couple of flash HAL's.

The AT45DB HAL has two components, one for chip access and the other
providing volume information: ::

  component At45dbC
  {
    provides {
      interface At45db;
      interface Resource[uint8_t client];
      interface ResourceController;
      interface ArbiterInfo;
    }
  } ...

  configuration At45dbStorageManagerC {
    provides interface At45dbVolume[volume_id_t volid];
  } ...


Note that the AT45DB HAL resource management is independent of the
underlying HPL's power management. The motivation for this is that
individual flash operations may take a long time, so it may be desirable to
release the flash's bus during long-running operations. The ``At45db``
and ``At45dbVolume`` interfaces are: ::

   interface At45db {
     command void write(at45page_t page, at45pageoffset_t offset,
                        void *PASS data, at45pageoffset_t n);
     event void writeDone(error_t error);

     command void erase(at45page_t page, uint8_t eraseKind);
     event void eraseDone(error_t error);

     command void copyPage(at45page_t from, at45page_t to);
     event void copyPageDone(error_t error);

     command void sync(at45page_t page);
     command void syncAll();

     event void syncDone(error_t error);

     command void flush(at45page_t page);
     command void flushAll();
     event void flushDone(error_t error);

     command void read(at45page_t page, at45pageoffset_t offset,
                       void *PASS data, at45pageoffset_t n);
     event void readDone(error_t error);

     command void computeCrc(at45page_t page, at45pageoffset_t offset,
                             at45pageoffset_t n, uint16_t baseCrc);
     event void computeCrcDone(error_t error, uint16_t crc);
   }

   interface At45dbVolume {
     command at45page_t remap(at45page_t volumePage);
     command at45page_t volumeSize();
   }

The STMicroelectronics M25P HAL is: ::

  configuration Stm25pSectorC {
    provides interface Resource as ClientResource[storage_volume_t volume];
    provides interface Stm25pSector as Sector[storage_volume_t volume];
    provides interface Stm25pVolume as Volume[storage_volume_t volume];
  }

and the ``Stm25pSector`` and ``Stm25pVolume`` interfaces are: ::

   interface Stm25pSector {
     command stm25p_addr_t getPhysicalAddress( stm25p_addr_t addr );
     command uint8_t getNumSectors();

     command error_t read(stm25p_addr_t addr, void* buf, stm25p_addr_t len);
     event   error_t readDone(stm25p_addr_t addr, void* buf, stm25p_addr_t len,
                              error_t error);

     command error_t write(stm25p_addr_t addr, void* buf, 
                           stm25p_addr_t len);
     event   error_t writeDone(stm25p_addr_t addr, void* buf, 
                               stm25p_addr_t len, error_t error);

     command error_t erase(uint8_t sector, uint8_t num_sectors);
     event   error_t eraseDone(uint8_t sector, uint8_t num_sectors, 
                               error_t error);

     command error_t computeCrc(uint16_t crc, stm25p_addr_t addr, 
                                stm25p_len_t len );
     event void computeCrcDone(stm25p_addr_t addr, stm25p_len_t len, 
                               uint16_t crc, error_t error);
   }

   interface Stm25pVolume {
     async event volume_id_t getVolumeId();
   }

Note that the M25P HAL integrates volume management and chip access
within the ``Stm25pSector`` interface.

3.3 Hardware Interface Layer (HIL)
--------------------------------------------------------------------

The HIL implementations are system-independent, but chip (family)
dependent. They implement the three storage abstractions and
volume structure discussed in Section 2.

a. Volumes

   The division of the flash chip into fixed-size volumes is specified by
   an XML file that is placed in the application's directory (where one
   types 'make'). The xml file specifies the allocation as follows: ::

     <volume_table>
       <volume name="DELUGE0" size="65536" />
       <volume name="CONFIGLOG" size="65536" />
       <volume name="DATALOG" size="131072" />
       <volume name="GOLDENIMAGE" size="65536" base="983040" />
     </volume_table>

   The name and size parameters are required, while base is
   optional. The name is a string containing one or more characters in
   [a-zA-Z0-9\_], while size and base are in bytes. Each storage chip
   MUST provide a compile-time tool that translates the allocation
   specification to chip-specific nesC code. There is no constraint on
   how this is done or what code is produced, except that the
   specification to physical allocation MUST be one-to-one (i.e. a
   given specification should always have the same resulting physical
   allocation on a given chip) and the result MUST be placed in the
   build directory. When not specified, the tool may give any suitable
   physical location to a volume. If there is any reason that the
   physical allocation cannot be satisfied, an error should be given
   at compile time.

   The compile-time tool MUST prepend 'VOLUME\_' to each volume name in
   the xml file and '#define' each resulting name to map to a unique
   integer. 

   The storage abstractions are accessed by instantiating generic
   components that take the volume macro as argument: ::

     components new BlockStorageC(VOLUME_DELUGE0);

   If the named volume is not in the specification, nesC will give a
   compile-time error since the symbol will be undefined.

   A volume MUST NOT be used with more than one storage abstraction
   instance.

b. Large object interface:

  Large objects are accessed by instantiating a BlockStorageC component
  which takes a volume id argument: ::

    generic configuration BlockStorageC(volume_id_t volid) {
      provides {
	interface BlockWrite;
	interface BlockRead;
      }
    } ...

  The ``BlockRead`` and ``BlockWrite`` interfaces contain the following
  operations: ::

     interface BlockWrite {
       command error_t write(storage_addr_t addr, void* buf, 
			     storage_len_t len);
       event void writeDone(storage_addr_t addr, void* buf, 
			    storage_len_t len, error_t error);

       command error_t erase();
       event   void    eraseDone(error_t result);

       command error_t commit();
	event  void    commitDone(error_t result);
     }

     interface BlockRead {
       command error_t read(addr_t addr, void* dest, addr_t len);
       event   void    readDone(storage_error_t result);

       command error_t verify();
       event   void    verifyDone(storage_error_t result);

       command error_t computeCrc(storage_addr_t addr, storage_len_t len,
				  uint16_t baseCrc);
       event   void    computeCrcDone(storage_addr_t addr, storage_len_t len, 
				      uint16_t crc, error_t error );

       command storage_len_t getSize();
     }

c. Large sequential objects:

  Large sequential objects are accessed by instantiating a LogStorageC
  component which takes a volume id and a boolean argument: ::

    generic configuration LogStorageC(volume_id_t volid, bool circular) {
      provides {
	interface LogWrite;
	interface LogRead;
      }
    } ...

  If the ``circular`` argument is TRUE, the log is circular; otherwise
  it is linear.

  The ``LogRead`` and ``LogWrite`` interfaces contain the following
  operations: ::

     interface LogWrite {
       command error_t erase();
       event   void    eraseDone(storage_error_t success);

       command error_t append(void* buf, storage_len_t len);
       event   void    appendDone(void* buf, storage_len_t len, error_t error);

       command storage_cookie_t currentOffset();

       command error_t sync();
       event   void    syncDone(storage_error_t success);
     }

     interface LogRead {
       command error_t read(void* buf, storage_len_t len);
       event   void    readDone(void* buf, storage_len_t len, error_t error);

       command storage_cookie_t currentOffset();

       command error_t seek(storage_cookie_t cookie);
       event   void    seekDone(error_t error);

       command storage_len_t getSize();
     }

d. Small objects:

  Small objects are accessed by instantiating a ConfigStorageC component
  which takes a volume id argument: ::

    generic configuration ConfigStorageC(volume_id_t volid) {
      provides {
	interface Mount;
	interface ConfigStorage;
      }
    } ...

  A small object MUST be mounted (see the ``Mount`` interface) before 
  the first use.

  The ``Mount`` and ``ConfigStorage`` interfaces contain the following
  operations: ::

     interface Mount {
       command error_t mount();
       event void mountDone(error_t error);
     }

     interface ConfigStorage {
       command error_t read(addr_t addr, void* dest, addr_t len);
       event   void    readDone(storage_error_t result);

       command error_t write(addr_t addr void* source, addr_t len);
       event   void    writeDone(storage_error_t result);

       command error_t commit();
       event   void    commitDone(storage_error_t result);

       command storage_len_t getSize();

       command bool valid();
     }

4. Implementation
====================================================================

An AT45DB implementation can be found in tinyos-2.x/tos/chips/at45db.

An STM25P implementation can be found in tinyos-2.x/tos/chips/stm25p.
 
5. Authors' Addresses
====================================================================

| David Gay
| 2150 Shattuck Ave, Suite 1300
| Intel Research
| Berkeley, CA 94704
|
| phone - +1 510 495 3055
| email - david.e.gay@intel.com
|
|
| Jonathan Hui
| 657 Mission St. Ste. 600
| Arched Rock Corporation
| San Francisco, CA 94105-4120
|
| phone - +1 415 692 0828
| email - jhui@archedrock.com
