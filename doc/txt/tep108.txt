============================
Resource Arbitration
============================

:TEP: 108
:Group: Core Working Group
:Type: Documentary
:Status: Draft
:TinyOS-Version: 2.x
:Authors: Kevin Klues, Philip Levis, David Gay, David Culler, Vlado Handziski

:Draft-Created: 28-Mar-2005
:Draft-Version: $Revision: 1.1.2.6.2.2 $
:Draft-Modified: $Date: 2006-06-21 17:37:46 $
:Draft-Discuss: TinyOS Developer List <tinyos-devel at mail.millennium.berkeley.edu>

.. Note::

    This memo documents a part of TinyOS for the TinyOS Community, and
    requests discussion and suggestions for improvements.  Distribution
    of this memo is unlimited. This memo is in full compliance with
    TEP 1.

Abstract
====================================================================

This memo documents the general resource sharing mechanisms for TinyOS
2.x. These mechanisms are used to allow multiple software components to
arbitrate access to shared abstractions.


1. Introduction
====================================================================

TinyOS 1.x has two mechanisms for managing shared resources:
virtualization and completion events. A virtualized resource appears
as an independent instance of an abstraction, such as the Timer
interface in the TimerC component. A client of a Timer instance can use it
without being aware of the possibility that other Timer clients may
exist.  TimerC virtualizes the underlying hardware clock into N
separate timers.

Some abstractions are not well suited to virtualization, however.
Sometimes a program needs full control of a shared resource.  To
accomplish this, a physical (rather than virtual) abstraction is
needed. For example, components in 1.x share a single communication
stack, through the use of the GenericComm component.  GenericComm can
only handle one outgoing packet at a time. If a component tries to
send a packet when GenericComm is already busy, then the call returns
FAIL. Only once GenericComm has signalled a completion event are any
other components allowed to gain control of it.  TinyOS 1.x provides
the mechanism of a global completion event which is signalled whenever
a packet send completes. Interested components can handle this event
and retry as needed.  In this way, the shared use of GenericComm
follows a first-come, first-served arbitration policy.

This approach to providing this type of physical abstraction has
several drawbacks:

- If you need to make several requests, you have to handle the
  possibility of a request returning FAIL at any point. This complicates  
  implementations with the addition of internal states in each of the
  components using the shared resource.

- You have no control over the timing of a sequence of operations.
  The global completion event will be signalled back to each of the
  shared resource clients in an arbitrary order.  There is no way
  of controlling which client will actually receive the signal first.
  One example of when this can be a problem is with timing-sensitive
  use  of an A/D converter.

- If this abstraction is built on top of an actual hardware resource
  that supports reservation, you cannot express this
  via this software interface. For instance, I2C buses have a  
  concept of "repeated start" when doing multiple bus transactions, 
  but it is not clear how to use this in TinyOS 1.x's I2C abstraction.

- Most TinyOS 1.x services do not provide a very convenient way of
  monitoring an abstraction's availability for the purpose of retries,
  nor very clear documentation on which requests could
  potentially happen simultaneously.

It should be clear that a single approach to resource sharing is not
appropriate for all circumstances. The following section addresses
this issue by introducing the concept of resource classes.  The
sharing policy used by a particular resource abstraction is dictated
by the resource class it belongs to.

2. Resource Classes
====================================================================

TinyOS 2.x distinguishes between three kinds of resource abstractions:
physical and dedicated, physical and shared, and virtual and shared.
Components offer resource sharing mechanisms appropriate to their
goals and level of abstraction. Section 2.1 discusses how access
control to physical and dedicated abstractions is generally handled
through nesC interfaces. Section 2.2 shows how access control
to virtualized abstractions can be handled through the use of
a particular software design pattern such as the Service Instance
[sipattern]_ and/or queueing design patterns. Section 2.3 introduces
the issues surrounding the most complex class of abstraction:
physical and shared.  The discussion of the components and interfaces
used to arbitrate access to this class are deferred to section 3,
however.

Since virtualization of a resource inevitably requires state
to be stored, Hardware Presentation Layer (HPL) components of the HAA
[TEP2]_ are always physical and never virtual. Depending on their
expected use, HPL abstractions can be either physical and dedicated or
physical and shared, however. For example, while physical hardware
timers are rarely multiplexed between multiple components, buses
almost always are. Correspondingly, on the MSP430, compare and counter
registers are physical and dedicated, while the USARTs are physical
and shared.

2.1 Physical and Dedicated
-------------------------------

An abstraction is *physical and dedicated* if it is a hardware resource
which a subsystem needs exclusive access to at all times. Generally, a
physical and dedicated abstraction is just an interface which its user
wires to and uses directly. In this class of resources, no sharing
policy is needed since only a single component ever has access to the
resource.  Examples of physical and dedicated abstractions include
interrupts and counters. For example, on the Atmega128 microprocessor,
Timer 2 is represented by the component HplAtm128Timer2C::

  module HplAtm128Timer2C {
    provides {
      interface HplTimer<uint8_t>   as Timer2;
      interface HplTimerCtrl8       as Timer2Ctrl;
      interface HplCompare<uint8_t> as Compare2;
    }
  }

Anyone wishing to use this dedicated hardware timer can wire to it
directly through this component.  

2.2 Virtual and Shared
-------------------------------

Virtual and shared abstractions hide multiple clients from each other
through software virtualization. Every client of the resource thinks
it has its own independent instance of the resource, but these
virtualized instances are multiplexed on top of a single underlying
resource. Because the virtualization is in software, there is no upper
bound on the number of clients that can connect to the abstraction,
barring memory or efficiency constraints. For example, the TimerMilliC
component provides a virtual and shared abstraction of millisecond
precision timers to application components [TEP102]_. As
virtualization usually requires keeping state and that state must
scale with the number of virtualized instances, virtualized resources
are designed around the Service Instance pattern[sipattern]_, which
is based on a parameterized interface. For example, TimerMilliC::

  configuration TimerMilliC {
    provides interface Init;
    provides interface Timer<TMilli> as TimerMilli[uint8_t num];
  }


Virtualization generally allows a client to use a very simple
interface. This simplicity comes at the cost of reduced efficiency and
an inability to precisely control the underlying resource. For
example, TimerMilli32C introduces CPU overhead from dispatching and
maintaining all of the virtual timers as well as jitter when two
timers want to fire at the same time.

2.3 Physical and Shared
-------------------------------

Physical and dedicated abstractions are useful when a resource is
always controlled by a single component. Virtualized abstractions are
useful when clients are willing to pay a bit of overhead and sacrifice
control in order to share a resource in a simple way. There are
situations, however, when many clients need precise control of a
resource. Clearly, they can't all have such control at the same time:
some degree of multiplexing is needed.

In TinyOS 2.x, a resource *arbiter* is responsible for this
multiplexing. The arbiter determines which client has access to the
resource. While a client holds a resource, it has complete and
unfettered control of it. Arbiters assume that clients are
cooperative, only acquiring the resource when needed and holding on to
it no longer than necessary. Clients explicitly release resources:
there is no way for an arbiter to forcibly reclaim it.

A motivating example of a physical and shared resource is a bus.
The bus may have multiple peripherals on it, corresponding to 
different subsystems. For example, on the Telos platform the flash
chip (storage) and the radio (network) share a bus. The storage and
network stacks need exclusive access to the bus when using it,
but they also need to share it with the other subsystem. In this
case, virtualization is problematic, as the radio stack needs to be
able to perform a series of operations in quick succession without
having to reacquire the bus in each case. Having the bus be a
physical but shared resource allows the radio stack to 
send a series of operations atomically across to the radio without
having to buffer them all up in memory beforehand (which would 
introduce memory pressure).

3. Resource Arbiters
====================================================================

Physical and shared resources have an *arbiter* to manage which client
can use the resource at any given time. Because an arbiter is a
centralized place that knows whether the resource is in use, it also
provides information useful for a variety of other services, such as
power management. An arbiter MUST provide a parameterized Resource
interface as well as an instance of the ArbiterInfo interface. An
arbiter SHOULD also provide an instance of ResourceController and
ResourceConfigure interfaces. An arbiter MAY provide additional
interfaces or instance of interfaces in order to provide a particular
arbitration policy.  Each of these interfaces is described in more
detail in the following few subsections.

3.1 Resource
-------------------------------

Clients of a physical and shared resource arbiter request access 
using the Resource interface::

  interface Resource {
    async command error_t request();
    event void granted();
    async command void release();
    async command isOwner();
  }

A client lets an arbiter know it needs access to a resource by
making a call to the request() command. If the resource is free,
SUCCESS is returned, and a granted event is immediately signalled back
to the client.  If the resource is busy, however, SUCCESS will still
be returned, but the granted event will not be signalled right away. 
Any requests made during this time are queued according to
some queing policy determined by the arbiter in use.  Once a client is
done with the resource it calls the release command, and the next
cleint in the request queue is signalled the granted event, giving it
exclusive access to the resource.  If a client ever makes multiple
calls to the request command before receiving a granted event, an
EBUSY value is returned, and the request is not queued.  In this way,
clients are not able to queue up multiple requests, thus blocking the
requests from other clients.

The isOwner command can be called by a client to see if it is the
current owner of the resource.  This command is mostly used
for runtime checks to make sure that clients not owning a resource
are not able to use it.  If a call to isOwner fails, then no call
should be made to commands provided by that resource.  An example of
where isOwner is used can be seen in the HplTda5250DataP component of
the Infeneon Tda5250 radio implementation::

  async command error_t HplTda5250Data.tx(uint8_t data) {
    if(call UartResource.isOwner() == FALSE)
      return FAIL;
    call Usart.tx(data);
    return SUCCESS;
  }

A call to the HplTda5250Data.tx command will fail if the radio does
not currently have control of the underlying Usart resource.  If it
does, then the Usart.tx(data) command is called as it should be.

An arbiter MUST provide exactly one parameterized Resource interface,
where the parameter is a client ID, following the Service
Instance pattern[sipattern]_.  An arbitrated component SomeNameP MUST
#define SOME_NAME_RESOURCE to a string which can be passed to unique() 
to obtain a client id.  For instance, a component implementing an I2C
service might look like this::

  #include I2CPacket.h
  configuration I2CPacketP {
    provides interface Resource[uint8_t client];
    provides interface I2CPacket<I2CAddrSize>[uint8_t client];
  }
  implementation {
    components new FcfsArbiterC(I2CPACKET_RESOURCE) as Arbiter;
    components I2CPacketImplP() as I2C;
    ...
    
    Resource  = Arbiter;
    I2CPacket = I2C;
    ...
  }

where I2CPacket.h contains the #define for the resource::

  #ifndef I2CPACKETC_H
  #define I2CPACKETC_H
  #define I2CPACKET_RESOURCE "I2CPacket.Resource"
  #endif


The #define for the unique string must be placed in a separate file
because of the way nesC files are preprocessed: including the
I2CPacketP component isn't enough to ensure that macros #define'd in
I2CPacketP are visible in the referring component.

A generic configuration SHOULD wrap this component in order to export
a single Resource interface that refers to a unique client ID on every
new instantiation.  Wrapping the component in this way ensures that
each Resource client is given a unique client ID, with the added
benefit of properly coupling multiple components that all need to
refer to the same client ID.  For example, the configuration
component for the I2C service might look like this::

  #include I2CPacket.h
  generic configuration I2CPacketC {
    provides interface Resource;
    provides interface I2CPacket<I2CAddrSize>;
  }
  implementation {
    enum {
      CLIENT_ID = unique(I2CPACKET_RESOURCE),
    };
  
    components I2CPacketP as I2C;
    Resource = I2C.Resource[CLIENT_ID];
    I2CPacket = I2C.I2CPacket[CLIENT_ID]; 
  }

In this example, an instance of I2CPacket interface is coupled with
an instance of the Resource interface on every new instantiation of
the I2CPacketC component.  In this way, a single Resource and a
single I2CPacket interface can be exported by this component together 
for use by a client.

Clients of the I2C service would use it as follows::

  module I2CClientP {
    uses interface Resource as I2CResource;
    uses interface I2CPacket<I2CAddrSize>;
  } ...

  configuration I2CClientC { }
  implementation {
    components I2CClientP, new I2CPacketC();

    I2CClientP.I2CResource -> I2CPacketC.Resource;
    I2CUserM.I2CPacket -> I2CPacket.I2CPacket;
  }

Implementations of components similar to this one can be found in the
tinyos-2.x source tree in the tos/chips/atm128/i2c directory

3.2 ResourceController
-------------------------------

An arbiter SHOULD provide one instance of the ResourceController
interface and MAY provide more than one. The Resource interface is for
simple and basic use cases, where clients are peers that share the
resource in some equal fashion. ResourceController is for clients that
require additional information due to the policies of the arbiter and
how they use the resource.  The ResourceController interface is based
on Resource, but introduces two additional events, idle() and
requested(), and the command immediateRequest()::

  interface ResourceController {
    async command error_t request();
    async command error_t immediateRequest();
    event void granted();
    async command void release();
    async event void requested(); 
    async event void idle();
    async command isOwner();
  }


An arbiter signals the requested event if the client currently has the resource
and some other client has requested it. It signals the idle() event when 
no client holds the resource.  The immediateRequest command can be
used by the user of the ResourceController interface to request
immediate access to the resource.  If the resource is free, then
SUCCESS is returned, and the ResourceController is given immediate
access to the resource.  If the resource is busy, then FAIL is
returned. Requests through this command are not queued, and no granted
events are signalled.

ResourceController allows an arbiter to provide a much richer set of
policies than simple sharing. For example, arbiters that want to
incorporate a power management policy can provide ResourceController
for a power management component. The power management component can
detect when nobody is using the resource with idle(), acquire it
atomically with immediateRequest(), and power it down. When another
client requests the resource, the power manager will handle the
requested() event. It can then power up the resource and release it
when the power up completes.  See TEP 115 for details. The default
arbiters in TinyOS 2.x (see Section 4) all provide a single instance
of ResourceController, in order to enable power management as
described above.

ResourceController can also be used for special case clients: the
algorithm used to determine when its requests are handled in
comparison to instances of the Resource interface is arbiter
specific. Therefore, arbiters MAY provide one or more instances of
ResourceController.  For example, the FcfsPriorityArbiter has a single
high-priority client who is always granted access to the resource
before any other client. Other clients only obtain the resource if the
high-priority client has not requested it or when the high-priority
client releases it.

3.3 ArbiterInfo
-------------------------------

The ArbiterInfo interface allows a component to query the current 
status of an arbiter::

  interface ArbiterInfo {
    async command bool inUse();
    async command uint8_t userId();
  }


The ArbiterInfo interface has a variety of uses. For example, the resource 
implementation can use it to refuse requests from clients that do not
currently have access. In this case, the abstraction would need to provide
a parameterized interface for its operations so it could distinguish
between different clients. The client ID for its operations would
also need to be the same as the client ID for the arbiter.

Arbiters MUST provide an instance of the ArbiterInfo interface.

3.5 Cross-component reservation
-----------------------------------------------

In some cases, it is desirable to share the reservation of a
single resource across multiple components. For example, on the TI
MSP430, a single USART component can be used as an I2C bus, a UART,
or an SPI connection. Clearly, on this chip, a reservation of the I2C
bus implicitly restricts the corresponding UART and SPI
services from gaining access to the resource. Enforcing such a policy
can be accomplished in the framework described above by:

 1) Creating a set of unique ids for each service using the shared
    resource.

 2) Mapping these ids onto the ids of the underlying resource

Clients connecting to these services do not know that that  this
mapping is taking place.  As far as they are concerned, the only
arbitration taking place is between other clients using the same
service.  In the MSP430 example, a single client of the I2C bus could
be contending with a single client of the SPI connection, but they
would probably have the same service level client ID.  These two
service level client ids would be mapped onto 2 unique resource ids
for use by the shared USART component. The proper way to achieve this
mapping is through the use of generic components.  The example given
below shows how to perform this mapping for the SPI component on the
MSP430.  It is done similarly for the UART and I2C bus::

  #include "Msp430Usart.h"
  generic configuration Msp430Spi0C() {
    provides interface Resource;
    provides interface SpiByte;
    provides interface SpiPacket;
  }
  implementation {
    enum {
      CLIENT_ID = unique(MSP430_SPIO_BUS),
    };

    components Msp430Spi0P as SpiP;
    Resource = SpiP.Resource[ CLIENT_ID ];
    SpiByte = SpiP.SpiByte;
    SpiPacket = SpiP.SpiPacket[ CLIENT_ID ];

    components new Msp430Usart0C() as UsartC;
    SpiP.UsartResource[ CLIENT_ID ] -> UsartC.Resource;
    SpiP.UsartInterrupts -> UsartC.HplMsp430UsartInterrupts;
  }


The definition of the MSP430_SPIO_BUS string is defined in
Msp430Usart.h. A unique id is created from this string every time a
new Msp430Spi0C component is instantiated.  This id is used as a
parameter to the parameterized Resource interface provided by the
Msp430Spi0P component.  This is where the mapping of the two
different ids begins.  As well as *providing* a parameterized
Resource interface, the Msp430Spi0P component also *uses* a
parameterized Resource interface. Whenever a cleint makes a call
through the provided Resource interface with id CLIENT_ID, an
underlying call to the used Resource interface with the same id is
implicitly made.  By wiring the used Resource interface with id
CLIENT_ID to the instance of the Resource interface provided by the
instantiation of the Msp430Usart0C component, the mapping is complete.
Any calls to the Resource interface provided by a new instantiation of
the Msp430Spi0C component will now be made through a unique Resource
interface on the underlying  Msp430Usart0C component.

This level of indirection is necessary because it may not always be
desirable to directly wire the service level Resource interface to
the underlying shared Resource interface.  Sometimes we may want to
perform some operations between a service level command being
called, and calling the underlying command on the shared resource. 
With such a mapping, inserting these operations is made possible.

Having such a mapping is also important for services that need to
explicitly keep track of the number of clients they have,
independent from how many total clients the underlying shared
resource has.  For example, a sensor implementation that uses an
underlying ADC resource may wish to power down its sensor whenever it
has no clients.  It doesn't want to have to wait until the entire ADC
is free to do so.  Providing this mapping allows the implicit power
manager components described in TEP 115 to be wired in at both levels
of the abstraction without interfering with one another.  In this
way, implementations of these components become much simpler, and code
reuse is encouraged.

Implementations of components similar to this one can be found in the
tinyos-2.x source tree in the tos/chips/msp430/uart directory

3.4 ResourceConfigure
-------------------------------

The ResourceConfigure interface provides a mechanism for clients
that need to use a resource with different configurations to do so.
Rather than forcing a client to reconfigure the resource itself, the
component representing a client can wire to an arbiter's
ResourceConfigure interface, which is called just before granting the
cleint the resource.

For example, the MSP430 USART0 bus can operate in three modes: SPI, I2C, and
UART. Using all three concurrently is problematic: only one should be enabled
at any given time. However, different clients of the bus might
require the bus to be configured for different protocols. For example,
Telos sensors use an I2C bus, while the radio and flash chip use SPI.

Arbiters MAY provide a parameterized ResourceConfigure interface::

  interface ResourceConfigure {
    async command void configure();
    async command void unconfigure();
  }


The parameter is the client ID, and corresponds directly to an instance of
the Resource interface. For example::

  generic component RoundRobinArbiterC {
    provides {
      interface Resource[uint8_t id];
      interface ResourceController;
      interface ArbiterInfo;
    }
    uses {
      interface ResourceConfigure[uint8_t id];
    }
  }


If an arbiter uses the ResourceConfigure interface, it MUST call
ResourceConfigure.configure() on the granted client ID before it
signals the Resource.granted() event. Similarly, after a valid
call to Resource.release(), it MUST call
ResourceConfigure.unconfigure() on the releasing client ID.

Using a parameterized interface that calls out rather than ad
ditional commands being put into the Resource interface
simplifies code reuse. Introducing these new commands into the
Resource interface could lead to a large number of clients all
including redundant configuration code, while using the call out
approach provided by the parameterized interface will only have one
instance of the code. For example, a component providing the SPI
service on top of the shared USART component on the MSP430 might look
like this::

  generic configuration Msp430Spi0C() {
    provides interface Resource;
    provides interface SpiByte;
    provides interface SpiPacket;

    uses interface Msp430SpiConfigure;
  }
  implementation {
    components new Msp430Usart0C;
    ...
  
    components Msp430Spi0Configure as Configure;
    Msp430Usart0C.ResourceConfigure -> Configure;
    ...
  }

The implementations of the configure and unconfigure commands are
kept in the Msp430Spi0Configure component and wired into the instance
of the Msp430Usart0C component.  In this way, different instances of
the Msp430Usart0C can each ahve different configuration associated
with them.

Arbiters SHOULD provide a parameterized ResourceConfigure interface.

4. Default arbiters
====================================================================

Because most components use one of a small number of arbitration
policies, TinyOS includes a number of default resource arbiters, in
the form of generic components, which all include this signature::

  generic module ArbiterC {
    provides interface Resource[uint8_t id];
    provides interface ResourceController;
    provides interface ArbiterInfo;
    uses interface ResourceConfigure[uint8_t id];
  }


For example, RoundRobinArbiterC provides round-robin arbitration. This
arbiter assigns a fixed order to all clients and grants outstanding
requests in that order based on client ID. FcfsArbiterC
provides a FIFO order, where requests are serviced in the order they
are received. FcfsPriorityArbiterC is similar to FcfsArbiterC, but
provides an additional ResourceController interface for the
high-priority client.

Implementations of these arbiters can be found in the tinyos-2.x
source tree in the tos/system/arbiters directory

5. Author's Address
====================================================================

| Kevin Klues
| 503 Bryan Hall
| Washington University
| St. Louis, MO 63130
|
| phone - +1-314-935-6355
| email - klueska@cs.wustl.edu
|
| Philip Levis
| 358 Gates Hall
| Stanford University
| Stanford, CA 94305-9030
|
| phone - +1 650 725 9046
| email - pal@cs.stanford.edu
|
| David Gay
| 2150 Shattuck Ave, Suite 1300
| Intel Research
| Berkeley, CA 94704
|
| phone - +1 510 495 3055
| email - david.e.gay@intel.com
|
| David Culler
| 627 Soda Hall
| UC Berkeley
| Berkeley, CA 94720
|
| phone - +1 510 643 7572
| email - culler@cs.berkeley.edu
|
|
| Vlado Handziski
| Sekr FT5
| Einsteinufer 25
| 10587 Berlin
| GERMANY
|
| email - handzisk@tkn.tu-berlin.de

6. Citations
====================================================================

.. [TEP2] TEP 2: Hardware Abstraction Architecture. 
.. [TEP102] TEP 102: Timers. 
.. [sipattern] TEP XXX: Service Instance Pattern. 
