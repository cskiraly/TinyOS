<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.5: http://docutils.sourceforge.net/" />
<title>Power Management of Non-Virtualised Devices</title>
<meta name="author" content="Kevin Klues, Vlado Handziski, Jan-Hinrich Hauer, Phil Levis" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@python.org
:Date: $Date: 2007-02-01 17:44:49 $
:Revision: $Revision: 1.7 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="power-management-of-non-virtualised-devices">
<h1 class="title">Power Management of Non-Virtualised Devices</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">115</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Core Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Documentary</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.x</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>Kevin Klues, Vlado Handziski, Jan-Hinrich Hauer, Phil Levis</td></tr>
<tr class="field"><th class="docinfo-name">Draft-Created:</th><td class="field-body">11-Jan-2006</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Version:</th><td class="field-body">1.5</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Modified:</th><td class="field-body">2006-12-12</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Discuss:</th><td class="field-body">TinyOS Developer List
&lt;tinyos-devel at mail.millennium.berkeley.edu&gt;</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This memo documents a part of TinyOS for the TinyOS Community, and
requests discussion and suggestions for improvements.  Distribution
of this memo is unlimited. This memo is in full compliance with TEP
1.</p>
</div>
<div class="section">
<h1><a id="abstract" name="abstract">Abstract</a></h1>
<p>This memo documents how TinyOS 2.x manages the power state of physical
(not virtualised) abstractions.</p>
</div>
<div class="section">
<h1><a id="introduction" name="introduction">1. Introduction</a></h1>
<p>The energy resources on a typical TinyOS platform are limited, so
every effort should be made to put all devices on a given platform
into their lowest possible power state as often as
possible. Depending on the device type, selecting the correct
power state could be as simple as switching between on and
off states, or involve selecting the optimum state from among
several. Choosing the best possible power state requires making
tradeoffs between various factors such as power consumption, fidelity,
performance, and wake-up latency.</p>
<p>Unfortunately, it is not feasible do design a unified one size-fits-all power
management strategy for use by all types of devices. Some devices
(particularly microcontollers) have direct access to internal registers that
allow them to efficiently calculate their lowest possible power state
very quickly.  Other devices do not have this information readily available and
would have to calculate it on the fly if other mechanisms were not in place to
prevent this.  Designing a general system wide power control algorithm to handle
all such devices would most likely be overly complex and in some cases even
suboptimal. TinyOS 2.x, therefore, takes the approach of defining two different
classes of devices for which different power-management strategies have been
optimized: microcontrollers and peripheral devices. As opposed to microcontrollers,
which normally contain a number of different valid power states, peripheral devices
tend to have only two distinct states they can be switched to (<em>on</em> and <em>off</em>).  Even
in the rare case where a device of this type happens to contain multiple power
states, TinyOS has traditionally used just the two most useful power states and
designated them to mean either <em>on</em> or <em>off</em>.  This TEP is dedicated to
describing power management for peripheral devices of this type.  Details on the
mechanisms used to perform microcontroller power management can be found in <a class="citation-reference" href="#tep112" id="id1" name="id1">[TEP112]</a>.</p>
<p>The term &quot;peripheral device&quot; specifically refers to any hardware device for which
the mechanisms described in <a class="citation-reference" href="#tep108" id="id2" name="id2">[TEP108]</a> can be used to provide resource arbitration
for them.  These devices are considered <em>non-virtualised</em> in the sense that
access to them must be explicitly requested and released by higher level
components wishing to use them.  Various policies can be implemented on top of
this class of devices to decide exactly when they should be powered on or off.
The simplest policy involves leaving it up to the programmer
to ensure that a device is switched on or off whenever it should be.
Other policies involve automatically powering a device up or down
by monitoring whether any clients are currently connected to it
or not.  Depending on the type of power management policy desired,
different models should be followed when designing drivers for devices
of this class.</p>
</div>
<div class="section">
<h1><a id="power-management-models" name="power-management-models">2. Power Management Models</a></h1>
<p>In order to support both manual and automatic power management of
non-virtualised devices in TinyOS, two different power management models have
been defined: <em>explicit power management</em> and <em>implicit power management</em>.</p>
<p>The <em>explicit power management</em> model provides a means for a single
client to manually control the power state of a dedicated physical device
(as defined by <a class="citation-reference" href="#tep108" id="id3" name="id3">[TEP108]</a>).  Whenever this client tells the device to
power up or down it does so without delay.  This model can be
particularly useful when the control information driving the selection
of the proper power state of a device relies on external logic contained in
higher level components.  The following section discusses the <tt class="docutils literal"><span class="pre">StdControl</span></tt>,
<tt class="docutils literal"><span class="pre">SplitControl</span></tt>, and <tt class="docutils literal"><span class="pre">AsyncStdControl</span></tt> interfaces used to perform power
management of this type.</p>
<p>The <em>implicit power management</em> model, on the other hand, provides a
means for allowing the power state of a device to be controlled from
within the driver for that device itself.  Device drivers following
this model are never explicitly powered up or down by some external
client, but rather <em>require</em> some internal policy to be defined that
decides exactly when their power states should be changed.  This policy
could exist natively on the hardware of the physical device itself, or
be implemented on top of some lower level abstraction of a physical
device adhering to the <em>explicit power management</em> model.</p>
<p>For shared devices (as defined by <a class="citation-reference" href="#tep108" id="id4" name="id4">[TEP108]</a>), the information required to
determine if a device's clients require it to be powered on or not can
be inferred through the set of interfaces they provide.
Because of this fact, no StdControl-like interface needs to be provided
to any higher level components, and the <em>implicit power management</em> policy
in use can act accordingly whenever clients request or release the device.
Section 4.2 discusses this in more detail.:</p>
<pre class="literal-block">
               /|\                                    /|\
                |                                      |
          Data Interface                            Resource
                |                                      |
-----------------------------------------------------------------------
|             Shared Device (implicitly power managed)                |
-----------------------------------------------------------------------
               /|\                                    /|\
                |                                      |
          Data Interface                            Resource
                |                                      |
                |        ----------------------        |
                |        |    Power Manager   |        |
                |        ----------------------        |
                |          /|\            /|\          |
                |           |              |           |
                |      StdControl ResourceDefaultOwner |
                |           |              |           |
---------------------------------      --------------------------------
|        Dedicated Device       |      |            Arbiter           |
|  (explicitly power managed)   |      |                              |
---------------------------------      --------------------------------
</pre>
</div>
<div class="section">
<h1><a id="explicit-power-management" name="explicit-power-management">3. Explicit Power Management</a></h1>
<p>Just as in TinyOS 1.x, <tt class="docutils literal"><span class="pre">StdControl</span></tt> and <tt class="docutils literal"><span class="pre">SplitControl</span></tt> interfaces have
been defined for TinyOS 2.x in order to control the on and off power
states of devices adhering to the <em>explicit power management</em> model.
A third interface called <tt class="docutils literal"><span class="pre">AsyncStdControl</span></tt> has also been introduced
for components in which it is critical to have the ability to power
them on or off while running in asynchronous context. One of these
three interfaces MUST be provided by components wrapping a hardware
device that supports switching between the devices on and off power
states. The selection of the right interface depends on the latencies
involved in changing between these two states as well as the nature of
the code (sync or async) executing any of the interfaces commands.</p>
<div class="section">
<h2><a id="power-management-with-stdcontrol" name="power-management-with-stdcontrol">3.1 Power Management with <tt class="docutils literal"><span class="pre">StdControl</span></tt></a></h2>
<p>Whenever the powerup and powerdown times of a non-virtualised device
are negligible, they SHOULD provide the <tt class="docutils literal"><span class="pre">StdControl</span></tt> interface as
defined below:</p>
<pre class="literal-block">
interface StdControl {
  command error_t start();
  command error_t stop();
}
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">Powerup and powerdown times on the order of a few microseconds have
traditionally been considered negligible, and can be waited on using one of the
<em>BusyWait</em> interfaces described in <a class="citation-reference" href="#tep102" id="id5" name="id5">[TEP102]</a>.  Powerup and powerdown
times on the order of a few milliseconds, however, should not be
ignored, and MUST be hidden behind the use of the <tt class="docutils literal"><span class="pre">SplitControl</span></tt> interface
described later on in this section.</p>
</div>
<p>An external component MUST call <tt class="docutils literal"><span class="pre">StdControl.start()</span></tt> to power a
device on and <tt class="docutils literal"><span class="pre">StdControl.stop()</span></tt> to power a device off.  Calls to
either command MUST return either SUCCESS or FAIL.</p>
<p>Upon the successful return of a call to <tt class="docutils literal"><span class="pre">StdControl.start()</span></tt>, a
device MUST be completely powered on, allowing calls to commands of other
interfaces implemented by the device to succeed.</p>
<p>Upon the successful return of a call to <tt class="docutils literal"><span class="pre">StdControl.stop()</span></tt>, a
device MUST be completely powered down, and any calls to commands
of other interfaces implemented by that device MUST return FAIL or EOFF.</p>
<p>If a device is not able to complete the <tt class="docutils literal"><span class="pre">StdControl.start()</span></tt> or
<tt class="docutils literal"><span class="pre">StdControl.stop()</span></tt> request for any reason, it MUST return FAIL.</p>
<p>Based on these specifications, the following matrix has been created
to describe the valid return values for any call made through the
<tt class="docutils literal"><span class="pre">StdControl</span></tt> interface in one of the devices valid power states:</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="31%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Call</th>
<th class="head">Device On</th>
<th class="head">Device Off</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>StdControl.start()</td>
<td>SUCCESS</td>
<td>SUCCESS or FAIL</td>
</tr>
<tr><td>StdControl.stop()</td>
<td>SUCCESS or FAIL</td>
<td>SUCCESS</td>
</tr>
<tr><td>operation</td>
<td>depends</td>
<td>FAIL or EOFF</td>
</tr>
</tbody>
</table>
<p>Devices providing this interface would do so as shown below:</p>
<pre class="literal-block">
configuration DeviceC {
  provides {
    interface Init;
    interface StdControl;  //For Power Management
    ....
  }
}
</pre>
</div>
<div class="section">
<h2><a id="power-management-with-splitcontrol" name="power-management-with-splitcontrol">3.2 Power Management with <tt class="docutils literal"><span class="pre">SplitControl</span></tt></a></h2>
<p>When a device's powerup and powerdown times are non-negligible, the
<em>``SplitControl``</em> interface MUST be used in place of the <em>``StdControl``</em>
interface.  The definition of this interface can be seen below:</p>
<pre class="literal-block">
interface SplitControl {
  command error_t start();
  event void startDone(error_t error);
  command error_t stop();
  event void stopDone(error_t error);
}
</pre>
<p>An external component MUST call <tt class="docutils literal"><span class="pre">SplitControl.start()</span></tt> to power a
device on and <tt class="docutils literal"><span class="pre">SplitControl.stop()</span></tt> to power a device off.  Calls to
either command return one of SUCCESS or FAIL.</p>
<p>Successful calls to <tt class="docutils literal"><span class="pre">SplitControl.start()</span></tt> MUST signal one of
<tt class="docutils literal"><span class="pre">SplitControl.startDone(SUCCESS)</span></tt> or <tt class="docutils literal"><span class="pre">SplitControl.startDone(FAIL)</span></tt>.</p>
<p>Successful calls to <tt class="docutils literal"><span class="pre">SplitControl.stop()</span></tt> MUST signal one of
<tt class="docutils literal"><span class="pre">SplitControl.stopDone(SUCCESS)</span></tt> or <tt class="docutils literal"><span class="pre">SplitControl.stopDone(FAIL)</span></tt>.</p>
<p>Upon signaling a <tt class="docutils literal"><span class="pre">SplitControl.startDone(SUCCESS)</span></tt>, a device MUST
be completely powered on, and operation requests through calls to commands
of other interfaces implemented by the device MAY succeed.</p>
<p>Upon signalling a <tt class="docutils literal"><span class="pre">SplitControl.stopDone(SUCCESS)</span></tt>, a device MUST be
completely powered down, and any subsequent calls to commands of other
interfaces implemented by the device MUST return EOFF or FAIL.</p>
<p>If a device is powered on and a successful call to <tt class="docutils literal"><span class="pre">SplitControl.stop()</span></tt>
signals a <tt class="docutils literal"><span class="pre">SplitControl.stopDone(FAIL)</span></tt>, the device MUST still be fully
powered on, and operation requests through calls to commands of other
interfaces implemented by the device MAY succeed.</p>
<p>If a device is powered down and a successful call to <tt class="docutils literal"><span class="pre">SplitControl.start()</span></tt>
signals a <tt class="docutils literal"><span class="pre">SplitControl.startDone(FAIL)</span></tt>, the device MUST still be fully
powered down, and operation requests through calls to commands of other
interfaces implemented by the device MUST return EOFF or FAIL.</p>
<p>If a device is not able to complete the <tt class="docutils literal"><span class="pre">SplitControl.start()</span></tt> or
<tt class="docutils literal"><span class="pre">SplitControl.stop()</span></tt> requests for any reason, they MUST return
FAIL.</p>
<p>Calls to either <tt class="docutils literal"><span class="pre">StdControl.start()</span></tt> or <tt class="docutils literal"><span class="pre">StdControl.stop()</span></tt> while
a start or stop operation is pending MUST return SUCCESS, with the
anticipation that a corresponding <tt class="docutils literal"><span class="pre">StdControl.startDone()</span></tt> or
<tt class="docutils literal"><span class="pre">StdControl.stopDone()</span></tt> will be signaled in the future.</p>
<table border="1" class="docutils">
<colgroup>
<col width="34%" />
<col width="17%" />
<col width="18%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Call</th>
<th class="head">Device On</th>
<th class="head">Device Off</th>
<th class="head">Starting</th>
<th class="head">Stopping</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>SplitControl.start()</td>
<td>SUCCESS</td>
<td>SUCCESS
FAIL</td>
<td>SUCCESS</td>
<td>SUCCESS</td>
</tr>
<tr><td>SplitControl.stop()</td>
<td>SUCCESS
FAIL</td>
<td>SUCCESS</td>
<td>SUCCESS</td>
<td>SUCCESS</td>
</tr>
<tr><td>operation</td>
<td>depends</td>
<td>FAIL
EOFF
EOFF</td>
<td>FAIL
EOFF
SUCCESS</td>
<td>FAIL
EOFF</td>
</tr>
</tbody>
</table>
<p>Devices providing this interface would do so as shown below:</p>
<pre class="literal-block">
configuration DeviceC {
  provides {
    interface Init;
    interface SplitControl; \\ For Power Management
    ....
  }
}
</pre>
</div>
<div class="section">
<h2><a id="power-management-with-asyncstdcontrol" name="power-management-with-asyncstdcontrol">3.3 Power Management with <tt class="docutils literal"><span class="pre">AsyncStdControl</span></tt></a></h2>
<p>The commands and the events of the <em>``StdControl``</em> and the <em>``SplitControl``</em>
interfaces are synchronous and can not be called from within
asynchronous code (such as interrupt service routines, etc.). For the
cases when the power state of the device needs to be controlled from
within asynchronous code, the <em>``AsyncStdControl``</em> interface MUST be used
in place of the <em>``StdControl``</em> interface.  The definition of this
interface can be seen below:</p>
<pre class="literal-block">
interface AsyncStdControl {
  async command error_t start();
  async command error_t stop();
}
</pre>
<p>All of the semantics that hold true for devices providing the
<tt class="docutils literal"><span class="pre">StdControl</span></tt> interface also hold for this interface.</p>
<p>Devices providing this interface would do so as shown below:</p>
<pre class="literal-block">
configuration DeviceC {
  provides {
    interface Init;
    interface AsyncStdControl; \\ For Power Management
    ....
  }
}
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The <tt class="docutils literal"><span class="pre">AsyncStdControl</span></tt> interface should be provided whenever it might be
necessary to allow a device to be powered on or off while running in
async context.  If it is anticipated that a device <em>will</em> not (or more
likely <em>should</em> not) be powered on or off while in asynchronous context,
then the <tt class="docutils literal"><span class="pre">StdControl</span></tt> interface SHOULD be provided instead.  Components
that wish to power the device on or off from within async context would
then be required to post a task before doing so.  In practice,
<tt class="docutils literal"><span class="pre">AsyncStdControl</span></tt> is provided by low-level hardware resources, while
<tt class="docutils literal"><span class="pre">StdControl</span></tt> is provided by higher level services built on top of these
resources.</p>
</div>
</div>
</div>
<div class="section">
<h1><a id="implicit-power-management" name="implicit-power-management">4. Implicit Power Management</a></h1>
<p>While the <em>explicit power management</em> model provides the basic means
for controlling the power state of a device, it is void of any
policy about when, or how the power state of the device should be changed.
This does not represent a large problem for the simple case
of <em>dedicated</em> devices, but can become crucial for non-trivial cases
involving complex interdependencies between devices controlled by multiple
clients.</p>
<p>For example, if component <em>A</em> is a client of both component <em>B</em>
and component <em>C</em>, what happens with <em>B</em> and <em>C</em> if
<tt class="docutils literal"><span class="pre">StdControl.stop()</span></tt> is called on component <em>A</em> ? Should components
<em>B</em> and <em>C</em> also be stopped?  What about the reverse case where both
<em>B</em> and <em>C</em> are clients of the single shared component, <em>A</em>?  If
devices <em>B</em> and <em>C</em> are shut off, should <em>A</em> be shut off as well?
How can one decide when it is appropriate to cascade such powerup
and powerdown requests?</p>
<p>The complex nature of the problem is evident from the number of
unexpected behaviors in TinyOS 1.x involving <tt class="docutils literal"><span class="pre">StdControl</span></tt>. On several
platforms, one of the SPI buses is shared between the radio and the
flash device. On some of them, issuing <tt class="docutils literal"><span class="pre">StdControl.stop()</span></tt> on the
radio results in a series of cascaded calls that result in SPI bus
becoming disabled, rendering the communication with the flash impossible.
Of course, the right policy would involve tracking the clients of the
SPI bus and powering it off only once both the radio and the flash
devices were no longer using it. Conversely, the SPI bus should be
powered on whenever there is at least one active client.</p>
<p>The selection of the right power management policy to use is a complex
task that depends on the nature of the devices in use, their
interdependency, as well as on any specific application requirements.
For cases when some of these features are known a-priori or are
restricted in some sense, it is preferable that the system provide
architectural support for enforcing a meaningful <em>default</em> power-management
policy instead of passing that task on to the application programmer to be
solved on a case-by-case basis.</p>
<div class="section">
<h2><a id="power-management-policies" name="power-management-policies">4.1. Power Management Policies</a></h2>
<p>Just as generic arbiters are offered in TinyOS 2.x to provide the arbitration
functionality required by shared resources, generic power management policies are
also offered to allow the power management of non-virtualised devices to
be automatically control.</p>
<p>Through the use of the arbiter components described in <a class="citation-reference" href="#tep108" id="id6" name="id6">[TEP108]</a>, device
drivers implemented as shared resources provide the type of restricted
resource interdependency where default power-management policies can be offered.
The shared resource class defined in Section 2.3 of <a class="citation-reference" href="#tep108" id="id7" name="id7">[TEP108]</a>, provides a
well defined component interdependency, where a single resource is shared
among multiple clients. This relationship enables the definition of
default power-management policies that can be used to automatically power
the resource on and off.</p>
<p>The <em>Power Manager</em> component implementing one of these polices acts as
the <em>default owner</em> of the shared resource device and interacts with it
through the use of the ResourceDefaultOwner interface:</p>
<pre class="literal-block">
interface ResourceDefaultOwner {
  async event void granted();
  async command error_t release();
  async command bool isOwner();
  async event void requested();
  async event void immediateRequested();
}
</pre>
<p>Acting as the default owner, the <em>Power Manager</em> waits for the
<tt class="docutils literal"><span class="pre">ResourceDefaultOwner.granted()</span></tt> event to be signaled in order to
gain ownership over the resource device.</p>
<p>Once it owns the device, the <em>Power Manager</em> is free to execute its
power-management policy using the StdControl-like interface provided by the
underlying resource. Different power managers can implement different
policies. In the simplest case, this would involve an immediate power-down
via one of the <tt class="docutils literal"><span class="pre">stop()</span></tt> commands. When the power-state transition
involves non-negligible costs in terms of wake-up latency or power
consumption, the <em>PowerManager</em> might revert to a more intelligent
strategy that tries to reduce these effects. As pointed out in the
introduction, one such strategy might involve the use of a timer to defer
the power-down of the resource to some later point in time, giving any
resource clients a window of opportunity to put in requests before the
device is fully shut down.</p>
<p>Regardless of the power management policy in use, the <em>Power Manager</em>
remains owner of the resource as long as the resource is not requested
by one of its clients.  Whenever a client puts in a request, the
<em>Power Manager</em> will receive a <tt class="docutils literal"><span class="pre">ResourceDefaultOwner.requested()</span></tt> event
(or <tt class="docutils literal"><span class="pre">immediateRequested()</span></tt> event) from the arbiter it is associated with.
Upon receiving this event, the <em>Power Manager</em> MUST power up the
resource through the StdControl-like interface provided by the lower level
abstraction of the physical device. The <em>Power Manager</em> SHOULD release the
ownership of the resource (using the <tt class="docutils literal"><span class="pre">ResourceDefaultOwner.release()</span></tt>
command) but MUST wait until after the resource has been fully powered on
before doing so.</p>
<p>Modeling devices as shared resources and allowing them to be
controlled in the way described here, solves the problems outlined in
section 3 regarding how to keep track of when and how the
powerdown of nested resources should proceed.  The <em>Power Manager</em>
component answers the question of how, and the combination of the power
management policy being used and the reception of the
<tt class="docutils literal"><span class="pre">ResourceDefaultOwner.granted()</span></tt> and <tt class="docutils literal"><span class="pre">ResourceDefaultOwner.requested()</span></tt>
events answers the question of when.  As long as the resource at
the bottom of a large set of nested resource clients has been fully released,
the power mananger will be able to power down the resource appropriately.</p>
<p>Using the model described above, a resource that uses one of these policies
according to the <em>implicitly power management</em> model could be built as shown below:</p>
<pre class="literal-block">
module MyFlashP {
  provides {
    interface Init;
    interface SplitControl;
        interface Resource;
        interface FlashCommands;
        ...
  }
}
implementation {
  ...
}

generic module PowerManagerC(uint8_t POWERDOWN_DELAY) {
  provides {
        interface Init;
  }
  uses {
        interface SplitControl;
        interface ResourceDefaultOwner;
  }
}
implementation {
  ...
}

#define MYFLASH_RESOURCE &quot;MyFlash.resource&quot;
#define MYFLASH_POWERDOWN_DELAY       1000
configuration MyFlashC {
  provides {
        interface Init;
        interface Resource;
        interface FlashCommands;
  }
}
implementation {
  components new PowerManagerC(MYFLASH_POWERDOWN_DELAY)
      , FcfsArbiter(MYFLASH_RESOURCE)
      , MyFlashP;

  Init = MyFlashP;
  Resource = FcfsArbiter;
  FlashCommands = MyFlashP;

  PowerManagerC.ResourceDefaultUser -&gt; FcfsArbiter;
  PowerManagerC.SplitControl -&gt; MyFlashP;

}
</pre>
<p>This example implementation is built out of three components.  The
first component (<tt class="docutils literal"><span class="pre">MyFlashP</span></tt>) follows the <em>explicit power management</em>
model for defining the interfaces to the physical flash device.  The
second component (<tt class="docutils literal"><span class="pre">PowerManagerC</span></tt>) is the generic <em>Power Manager</em>
component that will be used to implement the specific power management
policy for this device.  The third component (<tt class="docutils literal"><span class="pre">MyFlashC</span></tt>) is the
configuration file that wires together all of the components required
by the implementation of of the device as it adheres to the <em>implicit power
management</em> model.  It includes the <tt class="docutils literal"><span class="pre">MyflashP</span></tt> and <tt class="docutils literal"><span class="pre">PowerManagerC</span></tt>
components, as well as an arbiter component for managing shared clients
of the device.  Notice how the <em>Power Manager</em> is wired to both the
<tt class="docutils literal"><span class="pre">ResourceDefaultUser</span></tt> interface provided by the arbiter, and the
<tt class="docutils literal"><span class="pre">SplitControl</span></tt> interface provided by the flash.  All clients of this flash
device are directly connected to the resource interface provided by
the arbiter.  As outlined above, the <tt class="docutils literal"><span class="pre">PowerManagerC</span></tt> component will use
the events signaled through the <tt class="docutils literal"><span class="pre">ResourceDefaultUser</span></tt> interface to determine
when to make calls to power the device up and power it down through
the <tt class="docutils literal"><span class="pre">SplitControl</span></tt> interface.</p>
</div>
<div class="section">
<h2><a id="example-power-managers-powermanagerc-and-deferredpowermanagerc" name="example-power-managers-powermanagerc-and-deferredpowermanagerc">4.2. Example Power Managers: PowerManagerC and DeferredPowerManagerC</a></h2>
<p>TinyOS 2.x currently has two default power management policies
that it provides.  These policies are implemented by the various
components located under tinyos-2.x/lib/power. The first policy
is implemented using an <em>immediate</em> power control scheme, whereby
devices are powered on and off immediately after they have been
requested and released.  The second policy is implemented using
a <em>deferred</em> power control scheme, whereby devices are powered
on immediately after being requested, but powered off after
some small delay from being released.</p>
<p>Each policy has three different implementations for use by each of
the <tt class="docutils literal"><span class="pre">StdControl</span></tt>, <tt class="docutils literal"><span class="pre">SplitControl</span></tt>, and <tt class="docutils literal"><span class="pre">AsyncStdControl</span></tt>
interfaces.</p>
<p>For reference, each of the available components are listed below</p>
<dl class="docutils">
<dt>Immediate Power Management:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">StdControlPowerManagerC</span></tt></li>
<li><tt class="docutils literal"><span class="pre">SplitControlPowerManagerC</span></tt></li>
<li><tt class="docutils literal"><span class="pre">AsyncStdControlPowerManagerC</span></tt></li>
</ul>
</dd>
<dt>Deferred Power Management:</dt>
<dd><ul class="first last simple">
<li><tt class="docutils literal"><span class="pre">StdControlDeferredPowerManagerC</span></tt></li>
<li><tt class="docutils literal"><span class="pre">SplitControlDeferredPowerManagerC</span></tt></li>
<li><tt class="docutils literal"><span class="pre">AsyncStdControlDeferredPowerManagerC</span></tt></li>
</ul>
</dd>
</dl>
</div>
</div>
<div class="section">
<h1><a id="author-s-address" name="author-s-address">5. Author's Address</a></h1>
<div class="line-block">
<div class="line">Kevin Klues</div>
<div class="line">503 Bryan Hall</div>
<div class="line">Washington University</div>
<div class="line">St. Louis, MO 63130</div>
<div class="line"><br /></div>
<div class="line">phone - +1-314-935-6355</div>
<div class="line">email - <a class="reference" href="mailto:klueska&#64;cs.wustl.edu">klueska&#64;cs.wustl.edu</a></div>
<div class="line"><br /></div>
<div class="line">Vlado Handziski</div>
<div class="line">Sekr FT5</div>
<div class="line">Einsteinufer 25</div>
<div class="line">10587 Berlin</div>
<div class="line">GERMANY</div>
<div class="line"><br /></div>
<div class="line">phone - +49 30 314 23831</div>
<div class="line">email - <a class="reference" href="mailto:handzisk&#64;tkn.tu-berlin.de">handzisk&#64;tkn.tu-berlin.de</a></div>
<div class="line"><br /></div>
<div class="line">Jan-Hinrich Hauer</div>
<div class="line">Sekr FT5</div>
<div class="line">Einsteinufer 25</div>
<div class="line">10587 Berlin</div>
<div class="line">GERMANY</div>
<div class="line"><br /></div>
<div class="line">phone - +49 30 314 23813</div>
<div class="line">email - <a class="reference" href="mailto:hauer&#64;tkn.tu-berlin.de">hauer&#64;tkn.tu-berlin.de</a></div>
<div class="line"><br /></div>
<div class="line">Philip Levis</div>
<div class="line">358 Gates Hall</div>
<div class="line">Stanford University</div>
<div class="line">Stanford, CA 94305-9030</div>
<div class="line"><br /></div>
<div class="line">phone - +1 650 725 9046</div>
<div class="line">email - <a class="reference" href="mailto:pal&#64;cs.stanford.edu">pal&#64;cs.stanford.edu</a></div>
</div>
</div>
<div class="section">
<h1><a id="citations" name="citations">6. Citations</a></h1>
<table class="docutils citation" frame="void" id="tep102" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5" name="tep102">[TEP102]</a></td><td>TEP 102: Timers.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep108" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a name="tep108">[TEP108]</a></td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>, <a class="fn-backref" href="#id4">3</a>, <a class="fn-backref" href="#id6">4</a>, <a class="fn-backref" href="#id7">5</a>)</em> TEP 108: Resource Arbitration.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="tep112" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1" name="tep112">[TEP112]</a></td><td>TEP 112: Microcontroller Power Management.</td></tr>
</tbody>
</table>
</div>
</div>
</body>
</html>
